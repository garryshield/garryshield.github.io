{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"about","text":"写在最前面！ 折腾 折腾 折腾 一直在折腾。 芳华落尽，风轻云淡。 默然回首才发现什么都没有改变，什么都没有留下。 去他妈的。 我要在这里安家。 The smaller the mind, the greater the conceit. 思想越狭隘，自负越膨胀。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"写在最前面！","text":"写在最前面！ 折腾 折腾 折腾 一直在折腾。 芳华落尽，风轻云淡。 默然回首才发现什么都没有改变，什么都没有留下。 去他妈的。 我要在这里安家。 The smaller the mind, the greater the conceit. 思想越狭隘，自负越膨胀。","link":"/2015/07/17/genesis/"},{"title":"Blog 主题功能演示","text":"1. 代码块 12345678910111213141516#!/bin/bash###### CONFIGACCEPTED_HOSTS=\"/root/.hag_accepted.conf\"BE_VERBOSE=falseif [ \"$UID\" -ne 0 ]then echo \"Superuser rights required\" exit 2figenApacheConf()&#123; echo -e \"# Host $&#123;HOME_DIR&#125;$1/$2 :\"&#125; 2. 相册 3. 用户输入 To switch directories, type cd followed by the name of the directory. To edit settings, press ctrl + , 4. 行内代码块 For example, &lt;section&gt; should be wrapped as inline.","link":"/2015/07/19/demo/"},{"title":"使用 Hexo 创建博客","text":"了解过的静态博客框架有 Hexo，Jekyll，Hugo 几种。 Hexo 基于 NodeJS Jekyll 基于 Ruby，由 Github 开发用来服务于 GitHub pages Hugo 基于 Go 静态站点框架的基本思路是本地创建然后生成静态页面后部署到服务器上。 这样做的好处是服务器不需要做类似页面处理，数据库处理之类的工作，只需要发送 Html, css, js, image... 1. 安装 Hexo 基于 NodeJS，安装之前先确保系统已经安装好 NodeJS。 1npm install -g hexo-cli 2. 初始化 全局安装好 Hexo CLI 后， 新建一个测试项目 hexo-learn-01，并初始化 12345cd ~/hexomkdir hexo-learn-01cd hexo-learn-01hexo init ./npm install 初始化后，Hexo 执行 tree -L 2 -I 'node_modules' ./ 查看： ./├── _config.yml # yml 配置文件├── package-lock.json ├── package.json # npm 包管理文件├── scaffolds # 新建文章时的模版文件│ ├── draft.md│ ├── page.md│ └── post.md├── source # 文章&amp;页面目录│ └── _posts└── themes # 主题目录 └── landscape5 directories, 6 files 3. 使用 hexo 命令： Usage: hexo &lt;command&gt;Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use 'hexo help [command]' for the detailed informationor you can check the docs: http://hexo.io/docs/ 4. 本地运行 1hexo server 启动后打开浏览器，访问 http://localhost:4000/ &nbsp; 5. 新建文章 1hexo new post 'my first post' hexo 会在 source/_posts/ 目录下生成 my-first-post.md 文件。 hexo 使用 MarkDown 文件格式来编写文章， 修改 my-first-post.md 如下： 12345678910---title: My first postdate: 2018-07-20 16:58:59tags:---This is my first post.blabla...blabla...blabla... 刷新浏览器，将看到我们新添加的文章。 &nbsp; 6. 发布 Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 我们以发布到 GitHub 上为例： 注：每次添加文章和修改文章后，都要发布一次。 在 GitHub 上新建一个 Repository 名字 hexo.learn.01 &nbsp; &nbsp; 首先需要安装 hexo-deployer-git 插件 1npm install hexo-deployer-git 然后修改 _config.yml 配置 注：请将如下配置替换成自己的 12345678...url: https://garryshield.github.ioroot: /hexo.learn.01/...deploy: - type: git repo: git@github.com:garryshield/hexo.learn.01.git ... 执行： 1hexo deploy 发布过程会有点慢，成功会提示 To github.com:garryshield/hexo.learn.01.git * [new branch] HEAD -&gt; gh-pagesBranch 'master' set up to track remote branch 'gh-pages' from 'git@github.com:garryshield/hexo.learn.01.git'.INFO Deploy done: git 浏览器打开 https://garryshield.github.io/hexo.learn.01/ 就能看到已经发布成功了。 &nbsp; 7. 参考链接 · Hexo blog framework","link":"/2015/08/24/hexo/"},{"title":"Linux 命令 - tree","text":"Linux tree 命令用于以树状图列出目录的内容。 执行 tree 指令，它会列出指定目录下的所有文件，包括子目录里的文件。 1. 常用 123456-a 所有文件包括隐藏文件-d 只显示目录-L level 只显示第几级-P pattern 只显示匹配的文件-I pattern 不显示匹配的文件-o filename 输出到文件，而不是 stdout 2. 实例 2.1. 层级 12// 列出目录 ./ 第一级文件名tree -L 1 ./ ./├── _config.yml├── node_modules├── package-lock.json├── package.json├── scaffolds├── source└── themes4 directories, 3 files 2.2. 过滤 12// 列出目录 ./ 第一级下【后缀为 .json 的文件和目录】及【其它】tree -P '*.json' -L 1 ./ // _config.yml 文件被过滤./├── node_modules├── package-lock.json├── package.json├── scaffolds├── source└── themes4 directories, 2 files 2.3. 筛选 12// 列出目录 ./ 第一级下除了 node_modules 的文件tree -I 'node_modules' -L 1 ./ // node_modules 目录被过滤./├── _config.yml├── package-lock.json├── package.json├── scaffolds├── source└── themes3 directories, 3 files 3. 语法 usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;] [--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;] ------- Listing options ------- -a All files are listed. -d List directories only. -l Follow symbolic links like directories. -f Print the full path prefix for each file. -x Stay on current filesystem only. -L level Descend only level directories deep. -R Rerun tree when max dir level reached. -P pattern List only those files that match the pattern given. -I pattern Do not list files that match the given pattern. --ignore-case Ignore case when pattern matching. --matchdirs Include directory names in -P pattern matching. --noreport Turn off file/directory count at end of tree listing. --charset X Use charset X for terminal/HTML and indentation line output. --filelimit # Do not descend dirs with more than # files in them. --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;. -o filename Output to file instead of stdout. -------- File options --------- -q Print non-printable characters as '?'. -N Print non-printable characters as is. -Q Quote filenames with double quotes. -p Print the protections for each file. -u Displays file owner or UID number. -g Displays file group owner or GID number. -s Print the size in bytes of each file. -h Print the size in a more human readable way. --si Like -h, but use in SI units (powers of 1000). -D Print the date of last modification or (-c) status change. -F Appends '/', '=', '*', '@', '|' or '&gt;' as per ls -F. --inodes Print inode number of each file. --device Print device ID number to which each file belongs. ------- Sorting options ------- -v Sort files alphanumerically by version. -t Sort files by last modification time. -c Sort files by last status change time. -U Leave files unsorted. -r Reverse the order of the sort. --dirsfirst List directories before files (-U disables). --sort X Select sort: name,version,size,mtime,ctime. ------- Graphics options ------ -i Don't print indentation lines. -A Print ANSI lines graphic indentation lines. -S Print with CP437 (console) graphics indentation lines. -n Turn colorization off always (-C overrides). -C Turn colorization on always. ------- XML/HTML/JSON options ------- -X Prints out an XML representation of the tree. -J Prints out an JSON representation of the tree. -H baseHREF Prints out HTML format with baseHREF as top directory. -T string Replace the default HTML title and H1 header with string. --nolinks Turn off hyperlinks in HTML output. ---- Miscellaneous options ---- --version Print version and exit. --help Print usage and this help message and exit. -- Options processing terminator.","link":"/2015/08/24/linux-cmd-tree/"},{"title":"VS Code 创建代码片段","text":"Snippet 即代码段，指的是能够帮助输入重复代码模式，比如循环或条件语句的模板。 通过 Snippet 我们仅仅输入一小段字符串「prefix」，就可以在代码段引擎的帮助下，生成预定义的模板代码，接着我们还可以通过在预定义的光标位置之间跳转，来快速补全模板。 当然，看图更易懂。下图将 aja 补全为 JQuery 的 ajax() 方法，并通过光标的跳转，快速补全了待填键值对： &nbsp; 1. Snippet 配置流程 进入 Snippet 设置文件，这里提供了三种方法： 通过快捷键「Shift + Command + P」打开命令窗口（All Command Window），输入snippet，点选「首选项：配置用户代码段片段」。 点击界面最左侧竖栏（也即活动栏）最下方的齿轮按钮，在弹出来的菜单中点选「用户代码片段」。 下「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段。 2. Snippet 详细介绍 设置文件头部的一个块注释给出了设置 Snippet 的格式 1234567891011&#123; \"Print to console\": &#123; \"prefix\": \"log\", \"body\": [ \"console.log('$1');\", \"$2\" ], \"description\": \"Log output to console\" &#125;, ...&#125; Snippet 由三部分组成： prefix：前缀，定义了 Snippet 关键字; body： 主体，即模板的主体内容，其中每个字符串表示一行; description：说明，候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。 2.1. Snippet 主体 主体部分可以使用特殊语法结构，来控制光标和要插入的文本。支持的基本结构如下： 2.1.1. Tabstops：制表符 「Tabstops」可以让编辑器的指针在 Snippet 内跳转。 使用 $1，$2 等指定光标位置。这些数字指定了光标跳转的顺序。 $0 表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新 2.1.2. Placeholders：占位符 「Placeholder」是带有默认值的「Tabstops」。 如 ${1:Placeholder}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。 2.1.3. Choice：可选项 「Choice」是提供可选值的「Placeholder」。 语法为一系列用逗号隔开，并最终被两个竖线圈起来的枚举值， 比如 ${1|one,two,three|}。当光标跳转到该位置的时候，用户将会被提供多个值 [one, two, three] 以供选择。 2.1.4. Variables：变量 使用 $name 或 ${name:Placeholder} 可以插入变量的值。 当变量未赋值时，将插入其缺省值或空字符串。 当变量未知时，将插入变量的名称，并将其转换为「Placeholder」。 文件&amp;内容相关变量： TM_SELECTED_TEXT 选中的文本 TM_CURRENT_LINE 行内容 TM_CURRENT_WORD 光标所在的单词 TM_LINE_INDEX 行号（0为基） TM_LINE_NUMBER 行号（1为基） TM_FILENAME 文件名 TM_FILENAME_BASE 文件名无后缀 TM_DIRECTORY 文件所在目录 TM_FILEPATH 文件路径 CLIPBOARD 剪贴板内容 时间相关的变量： CURRENT_YEAR 年 CURRENT_YEAR_SHORT 年（两位） CURRENT_MONTH 月（两位），如 02； CURRENT_MONTH_NAME 月份的全称，如 July； CURRENT_MONTH_NAME_SHORT 月份的简称，如 Jul； CURRENT_DATE 月份第几天 CURRENT_DAY_NAME 周，如 Monday； CURRENT_DAY_NAME_SHORT 周简称，如 Mon； CURRENT_HOUR 时 CURRENT_MINUTE 分 CURRENT_SECOND 秒 3. 参考链接 · VS Code · Creating your own snippets","link":"/2015/09/12/vscode-snippets/"},{"title":"MacOS 开源的录屏工具 - kap","text":"Kap 是一个开源的录屏工具，支持导出 GIF，MP4，WebM，APNG。同时可以自己编写插件用来分享，转化... 官网： Kap GitHub 网址： Kap GitHub 1. 安装 1.1. 通过 brew 安装 12brew updatebrew cask install kap 1.2. 直接下载安装 下载最新版本 Kap Download 或者到 Kap Releases 页面下载其它版本。 2. 使用 2.1. 选择录制区域 启动后 Kap 会常驻在系统状态栏上。打开面板后看到一个红色按钮。点击它就可以在屏幕上进行录制区域的框选。 &nbsp; 框定的区域会用虚线标识出来，如果想要调整录制区域可以使用鼠标进行拖拽、拉伸来调整。 &nbsp; 要录制全屏或者指定窗口也可以直接选择。 &nbsp; 2.2. 录制 选择录制区域后，再次点击红色按钮，等到系统状态栏上的 Kap 图标变成实心后就进入录制模式。 &nbsp; 要结束录制只需要再次点击系统状态栏上的 Kap 图标，Kap 将打开录制结果窗口。 通过下方的导航，可以导出不同的格式。如果录制结果不理想，关闭本窗口从新录制即可。 &nbsp; 3. 设置 通过快捷键「Command + ‘」进入设置界面。 常用的设置项目： Save To 导出时存放目录 Start automatically 开机自动启动 Show mouse cursor 同时录制鼠标的移动 Keyboard shortcut to record 开启「Command + Shift + F5」快捷键 插件标签下按需求开启所需的插件，有兴趣按自己按官方说明自己扫插件 &nbsp; 4. 参考链接 · Kap Screen Recorder","link":"/2015/10/05/mac-tool-kap/"},{"title":"使用 nvm 管理 NodeJS","text":"同时开发多个项目，项目的需求不同，进而依赖不同版本的 NodeJS 运行环境。nvm 版本管理工具能够很方便的切换，而不用每次全局修改。 1. 安装 &amp; 更新 建议先删除系统安装的 node 和 npm，完全使用 nvm 来管理。 以 MacOS 为例： 123456brew uninstall node; // or `brew uninstall --force node` which removes all versionsbrew prune;rm -rf /opt/local/bin/node /opt/local/include/node /opt/local/lib/node_modulesrm -rf /usr/local/bin/npm /usr/local/share/man/man1/node.1 /usr/local/lib/dtrace/node.drm -rf ~/.npm ~/.npmrc ~/.node-gyp 安装 &amp; 升级 nvm 123curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash// orwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 2. 使用 2.1. 下载 &amp; 安装 注：写文章时最新版本是 v10.7.0，最新稳定版本是 v8.11.3。 1234567891011121314151617181920212223242526// 安装最新版 nodenvm install node// 安装稳定（LTS）版本nvm install --lts// nvm 遵守语义化版本命名规则。例如，你想安装 v10.7.0，可以运行：nvm install 10// 安装 v8.11.3 并同时安装 v10.7.0 下已安装的包nvm install 8 --reinstall-packages-from=10// 如果已经安装过 v8.11.3 则下面两行实现同样的效果nvm use 8nvm reinstall-packages 10// 安装 v8.11.3 后同时升级到最新的 npmnvm install 8 --latest-npm// 如果已经安装过 v8.11.3 则下面两行实现同样的效果nvm use 8nvm install-latest-npm// 下面两行实现同样的效果nvm use 8npm install -g npm 2.2. 查看指定版本路径 12345678nvm which current// ~/.nvm/versions/node/v10.7.0/bin/nodenvm which 10// ~/.nvm/versions/node/v10.7.0/bin/nodenvm which 8// ~/.nvm/versions/node/v8.11.3/bin/node 2.3. 查看已经安装的版本 1nvm ls v8.11.3-&gt; v10.7.0 // -&gt; 表示当前使用的版本default -&gt; 10 (-&gt; v10.7.0) // `default` 表示默认使用的版本node -&gt; stable (-&gt; v10.7.0) (default)stable -&gt; 10.7 (-&gt; v10.7.0) (default)iojs -&gt; N/A (default)lts/* -&gt; lts/carbon (-&gt; v8.11.3)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.14.3 (-&gt; N/A)lts/carbon -&gt; v8.11.3 2.4. 查看远程服务器上的可用版本 12345// 所有可用版本nvm ls-remote// 只列出稳定（LTS）版本nvm ls-remote --lts 2.5. 切换版本 12345678// 切换到 v8.11.3nvm use 8// 切换到 v10.7.0nvm use 10// 切换到稳定版（LTS）nvm use --lts 2.6. 以指定版本临时运行 12345678// 临时使用 v8.11.3 运行nvm run 8 -vnvm run 8 app.js// 临时使用 v8.11.3 运行，并使用 v8.11.3 的路径nvm exec 8 node -vnvm exec 8 node app.jsnvm exec 8 npm install -g lodash 2.7. 别名 如果安装的版本过多为了方便记住，可以使用别名代替每次输入版本号。 default 别名指向默认的版本。 12345678// nvm alias &lt;name&gt; &lt;version&gt;nvm alias default 8nvm alias n8 8nvm alias n10 10// nvm unalias &lt;name&gt;nvm unalias n8nvm unalias n10 3. 项目 .nvmrc 可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。 之后在项目目录中执行 nvm use, nvm install, nvm exec, nvm run, nvm which 即可。 .nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。 123echo \"8\" &gt; .nvmrcecho \"lts/*\" &gt; .nvmrcecho \"node\" &gt; .nvmrc 4. 常见问题 4.1. 使用 nvm 后加载不到全局包 有时候明明全局安装一个包，但是项目里就是引用不到，是因为 NODE_PATH 环境变量没有设置。修改 ~/.bash_profile 如下： 123// npm root -g 返回当前版本下 npm 包的路径// ~/.nvm/versions/node/v8.11.3/lib/node_modulesexport NODE_PATH=`npm root -g` 5. 参考链接 · Node Version Manager","link":"/2015/12/05/nvm/"},{"title":"查看 Linux 内核版本和发行版信息","text":"Linux 有众多发行版，在编辑通用脚本等工作时通常需要检测： 内核版本 Kernel Version 发行版信息 Distribution Information ... 来兼容它们。这里先挖个坑汇总一些基本命令和检测脚本，方便以后使用。 1. 内核版本 Kernel Version 12uname -a// Linux 72e1a384f328 4.9.87-linuxkit-aufs #1 SMP Wed Mar 14 15:12:16 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 2. 发行版信息 Distribution Information 发行版信息查看命令和具体的发行版本有关，可以通过如下方式依次判断： 2.1. /etc/*-release 文件 CentOS7 为例 12345678910111213141516171819202122232425ls /etc/ | grep 'release$'// centos-release// os-release// redhat-release// system-releasecat /etc/centos-release// CentOS Linux release 7.5.1804 (Core)cat /etc/os-release// NAME=\"CentOS Linux\"// VERSION=\"7 (Core)\"// ID=\"centos\"// ID_LIKE=\"rhel fedora\"// VERSION_ID=\"7\"// PRETTY_NAME=\"CentOS Linux 7 (Core)\"// ANSI_COLOR=\"0;31\"// CPE_NAME=\"cpe:/o:centos:centos:7\"// HOME_URL=\"https://www.centos.org/\"// BUG_REPORT_URL=\"https://bugs.centos.org/\"// // CENTOS_MANTISBT_PROJECT=\"CentOS-7\"// CENTOS_MANTISBT_PROJECT_VERSION=\"7\"// REDHAT_SUPPORT_PRODUCT=\"centos\"// REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 2.2. lsb_release 命令 部分系统默认没有安装 lsb_release，要手动安装 1234567yum install -y redhat-lsblsb_release -a// LSB Version: :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch// Distributor ID: CentOS// Description: CentOS Linux release 7.5.1804 (Core)// Release: 7.5.1804// Codename: Core 2.3. /proc/version 文件 12cat /proc/version// Linux version 4.9.87-linuxkit-aufs (root@95fa5ec30613) (gcc version 6.4.0 (Alpine 6.4.0) ) #1 SMP Wed Mar 14 15:12:16 UTC 2018 2.4. hostnamectl 命令 部分发行版使用了 Systemd，可以 hostnamectl 命令查看查看当前主机的信息 123456789101112hostnamectl// Static hostname: e36d66eda18f// Icon name: computer-vm// Chassis: vm// Machine ID: 6fb7133090d24396994f84269f86e21c// Boot ID: 980c73ee271a4df78941610e46befcc5// Virtualization: other// Operating System: CentOS Linux 7 (Core)// CPE OS Name: cpe:/o:centos:centos:7// Kernel: Linux 4.9.87-linuxkit-aufs// Architecture: x86-64 3. 检测脚本 3.1. sh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sh# Detects which OS and if it is Linux then it will detect which Linux Distribution.OS=`uname -s`REV=`uname -r`MACH=`uname -m`GetVersionFromFile()&#123; VERSION=`cat $1 | tr \"\\n\" ' ' | sed s/.*VERSION.*=\\ // `&#125;if [ \"$&#123;OS&#125;\" = \"SunOS\" ] ; then OS=Solaris ARCH=`uname -p` OSSTR=\"$&#123;OS&#125; $&#123;REV&#125;($&#123;ARCH&#125; `uname -v`)\"elif [ \"$&#123;OS&#125;\" = \"AIX\" ] ; then OSSTR=\"$&#123;OS&#125; `oslevel` (`oslevel -r`)\"elif [ \"$&#123;OS&#125;\" = \"Linux\" ] ; then KERNEL=`uname -r` if [ -f /etc/redhat-release ] ; then DIST='RedHat' PSUEDONAME=`cat /etc/redhat-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/redhat-release | sed s/.*release\\ // | sed s/\\ .*//` elif [ -f /etc/SUSE-release ] ; then DIST=`cat /etc/SUSE-release | tr \"\\n\" ' '| sed s/VERSION.*//` REV=`cat /etc/SUSE-release | tr \"\\n\" ' ' | sed s/.*=\\ //` elif [ -f /etc/mandrake-release ] ; then DIST='Mandrake' PSUEDONAME=`cat /etc/mandrake-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/mandrake-release | sed s/.*release\\ // | sed s/\\ .*//` elif [ -f /etc/debian_version ] ; then DIST=\"Debian `cat /etc/debian_version`\" REV=\"\" fi if [ -f /etc/UnitedLinux-release ] ; then DIST=\"$&#123;DIST&#125;[`cat /etc/UnitedLinux-release | tr \"\\n\" ' ' | sed s/VERSION.*//`]\" fi OSSTR=\"$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;PSUEDONAME&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)\"fiecho $&#123;OSSTR&#125; 3.2. python 12345678910111213// python3cd ~wget https://raw.githubusercontent.com/python/cpython/master/Lib/platform.pychmod +x platform.py./platform.py// Linux-4.9.87-linuxkit-aufs-x86_64-with-centos-7.5.1804-Core// python2cd ~wget https://raw.githubusercontent.com/python/cpython/2.7/Lib/platform.pychmod +x platform.py./platform.py// Linux-4.9.87-linuxkit-aufs-x86_64-with-centos-7.5.1804-Core 4. 参考链接 · Detecting Underlying Linux Distro","link":"/2016/02/20/linux-version/"},{"title":"Mac 修饰键和热键","text":"MacOS 键盘按键修饰符: GLYPH HTML Entity NAME  &amp;#63743; Apple ⌘ &amp;#8984; Command ⌥ &amp;#8997; Option ⇧ &amp;#8679; Shift ⌃ &amp;#8963; Control ⎋ &amp;#9099; Esc ⇪ &amp;#8682; Caps lock ⏏ &amp;#9167; Eject ↵ &amp;#8629; &amp;crarr; Return ⌫ &amp;#9003; Delete ⌦ &amp;#8998; Forward Delete → &amp;#8594; &amp;rarr; Right ← &amp;#8592; &amp;larr; Left ↑ &amp;#8593; &amp;uarr; Up ↓ &amp;#8595; &amp;darr; Down ⇞ &amp;#8670; Page Up ⇟ &amp;#8671; Page Down ↖ &amp;#8598; Home ↘ &amp;#8600; End ⌧ &amp;#8999; Clear ⇥ &amp;#8677; Tab ⇤ &amp;#8676; Shift Tab ␣ &amp;#9251; Space MacOS 常用的快捷键: 系统： ⌘ + tab 切换应用程序 ⌘ + ⌫ 将选中的文件移动到废纸篓 ⌘ + c 拷贝 ⌘ + v 粘贴 ⌘ + ⌥ + v 移动文件 ⌘ + q 退出当前应用 ⌘ + h 隐藏当前窗口 ⌘ + m 最小化当前窗口 ⌘ + w 关闭当前窗口 截图： ⌘ + ⇧ + 3 截屏并保存桌面 ⌘ + ⇧ + ⌃ + 3 截屏并保存剪贴板 ⌘ + ⇧ + 4 截区域并保存桌面 ⌘ + ⇧ + ⌃ + 4 截区域并保存剪贴板 文本导航: ⌃ + b 后移光标 ⌃ + f 前移光标 ⌃ + a 跳到行首 ⌃ + e 跳到行尾 ⌃ + u 删除光标前到行首 ⌃ + k 删除光标处到行尾 ⌃ + h 删除光标前的字符 ⌃ + d 删除光标处的字符 ⌃ + w 删除光标前的单词 ⌃ + y 粘贴最后一次的删除 ⎋ + b ⌥ + ← 后一个单词 ⎋ + f ⌥ + → 前一个单词 iTerm: ⌃ + p 前一条命令 ⌃ + n 后一条命令 ⌃ + r 查找相关历史命令 ⌘ + k 清屏 ⌘ + t 新建标签 ⌘ + n 新建窗口 ⌘ + → ⌘ + ← 切换标签 ⌘ + ⇧ + [ ⌘ + ⇧ + ] 切换标签 ⌘ + ⇧ + → ⌘ + ⇧ + ← 移动标签 ⌘ + d 新建垂直分隔面板 ⌘ + ⇧ + d 新建水平分隔面板 ⌘ + ⌥ + → ⌘ + ⌥ + ← ⌘ + ⌥ + ↑ ⌘ + ⌥ + ↓ 切换面板 ⌘ + ] 切换到下一个面板 ⌘ + [ 切换到上一个面板 ⌘ + ⌃ + → ⌘ + ⌃ + ← ⌘ + ⌃ + ↑ ⌘ + ⌃ + ↓ 调整面板 MacOS 快捷键设置： &nbsp; 使用 CheatSheet 查看当前软件的快捷键: &nbsp; 参考链接 · Mac keyboard shortcuts · CheatSheet","link":"/2016/04/24/mac-keyboard/"},{"title":"Systemd 定时器单元 - Timer","text":"Timers 是以 .timer 为后缀名的 systemd 单元文件，用于控制 .service 文件或事件。Timers 可用来代替 cron。Timers 内置了日历定时事件和单调定时事件的支持，并可以异步执行这些事件。 更多关于 Systemd 的说明参见 这篇文章。 1. 定时器单元 Timers 是以 .timer 为后缀的 systemd 单元文件。Timers 和其他单元配置文件是类似的，它通过相同的路径加载，不同的是包含了 [Timer] 部分。 [Timer] 部分定义了何时以及如何激活定时事件。Timers 可以被定义成以下两种类型： 1.1. 单调定时器 即从一个时间点过一段时间后激活定时任务。所有的单调计时器都遵循如下形式： OnTypeSec=。 OnBootSec 和 OnActiveSec 是常用的单调定时器。 1.2. 实时定时器 （类似于 cronjobs ） 通过日历事件激活定时任务。 使用 OnCalender= 来定义实时定时器。 要查阅完整的定时器选项参见 Timer unit configuration。 关于日历事件和时间段的定义参见 Time and date specifications. 2. 服务单元 每个 .timer 文件所在目录都得有一个对应的 .service 文件（如 foo.timer 和 foo.service）。.timer 用于激活并控制 .service 文件。 .service 文件中不需要包含 [Install] 部分，因为这由 timer 单元接管。必要时通过在定时器的 [Timer] 部分指定 Unit= 选项来控制一个与定时器不同名的服务单元。 更多服务单元说明参见 这篇文章。 3. 管理 使用 timer 单元时像其他单元一样 enable 或 start 即可（别忘了添加 .timer 后缀）。 3.1. 查看单元文件 1234567891011# 查看所有单元systemctl list-unit-files# 查看所有 Service 单元systemctl list-unit-files --type=service# 查看所有 Timer 单元systemctl list-unit-files --type=timer# 查看所有正在运行的定时器systemctl list-timers 3.2. 单元管理命令 1234567891011121314151617181920# 启动单元systemctl start foo.timer# 关闭单元systemctl stop foo.timer# 重启单元systemctl restart foo.timer# 杀死单元进程systemctl kill foo.timer# 查看单元状态systemctl status foo.timer# 开机自动执行该单元systemctl enable foo.timer# 关闭开机自动执行systemctl disable foo.timer 3.3. 日志相关命令 1234567891011121314# 查看整个日志journalctl# 查看 foo.timer 的日志journalctl -u foo.timer# 查看 foo.timer 和 foo.service 的日志journalctl -u foo# 从结尾开始查看最新日志journalctl -f# 从结尾开始查看 foo.timer 的日志journalctl -f -u foo.timer 4. 配置示例 4.1. 单调定时器 定义一个在系统启动 15 分钟后执行，且之后每周都执行一次的定时器。 /etc/systemd/system/foo.timer123456789[Unit]Description=Run foo weekly and on boot[Timer]OnBootSec=15minOnUnitActiveSec=1w [Install]WantedBy=timers.target 4.2. 实时定时器 定义一个每周执行一次（明确时间为周一上午十二点）且上次未执行就立即执行的定时器。 /etc/systemd/system/foo.timer123456789[Unit]Description=Run foo weekly[Timer]OnCalendar=weeklyPersistent=true [Install]WantedBy=timers.target 4.3. 定时器单元文件说明 OnActiveSec：定时器生效后，多少时间开始执行任务OnBootSec：系统启动后，多少时间开始执行任务OnStartupSec：Systemd 进程启动后，多少时间开始执行任务OnUnitActiveSec：该单元上次执行后，等多少时间再次执行OnUnitInactiveSec： 定时器上次关闭后多少时间，再次执行OnCalendar：基于绝对时间，而不是相对时间执行AccuracySec：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒Unit：真正要执行的任务，默认是同名的带有.service后缀的单元Persistent：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元WakeSystem：如果系统休眠，是否自动唤醒系统 5. 案例一：定时追加文本 5.1 创建脚本 123cd /roottouch backup_www.shchmod +x backup_www.sh backup_www.sh123456789#!/bin/bash# 向 /root/backup_www.txt 文件中追加当前时间mydate()&#123; date \"+%Y-%m-%d %H:%M:%S\"&#125;backupdate=$(mydate)echo $&#123;backupdate&#125; &gt;&gt; /root/backup_www.txt 5.2. 创建服务单元 /etc/systemd/system/backup_www.service1234567891011[Unit]Description=www backup service[Service]User=wwwGroup=wwwType=simpleExecStart=/root/backup_www.sh[Install]WantedBy=multi-user.target 5.2. 定时器单元 /etc/systemd/system/backup_www.timer1234567891011[Unit]Description=www backup timer[Timer]# 表示每 15 分钟执行一次OnCalendar=*:0/15Persistent=trueUnit=backup_www.service[Install]WantedBy=multi-user.target 5.3. 创建链接并启动 123456789101112systemctl enable backup_www.servicesystemctl enable backup_www.timersystemctl start backup_www.timersystemctl status backup_www.timer● backup_www.timer - www backup timer Loaded: loaded (/etc/systemd/system/backup_www.timer; enabled; vendor preset: disabled) Active: active (running) since Tue 2018-07-24 12:36:10 UTC; 10min agoJul 24 12:36:10 e36d66eda18f systemd[1]: Started www backup timer.Jul 24 12:36:10 e36d66eda18f systemd[1]: Starting www backup timer. 每隔一分钟运行 cat /root/backup_www.txt 查看运行结果: 2016-07-24 12:46:482016-07-24 12:47:482016-07-24 12:48:482016-07-24 12:49:482016-07-24 12:50:482016-07-24 12:51:482016-07-24 12:52:48 6. 参考链接 · Systemd GitHub · Systemd Office Site · Systemd Unit Man · Timer unit configuration · Time and date specifications","link":"/2016/05/20/systemd-timer/"},{"title":"NodeJS 的 Promise 的用法","text":"回调是JavaScript编程中比较令人纠结的写法，主要是用于处理“并列”或者“并行”的操作，然后在回调函数中处理操作结果。这样原生的回调写法就会带来一下的不便。 回调结果状态不便管理 回调方式自由松散，没有规范约束 例如下面的回调的写法： 123456789101112131415161718function func(num, callback) &#123; setTimeout(() =&gt; &#123; try &#123; let result = 1/num; callback(result, null); &#125; catch(err) &#123; callback(null, err); &#125; &#125;, 1000)&#125;func(1, (result, err) =&gt; &#123; if( err ) &#123; console.log(err) &#125; else &#123; console.log(result) &#125; &#125;) 上述代码中，发现如果要处理回调结果 result 和错误 err ，后续的所有就必须在回调函数里面处理，而且回调函数里面还需要自己处理异常判断。 那如果是使用了Promise来处理回调操作，就可以用以下写法处理。 1234567891011121314function func(num, callback) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; let result = 1/num; resolve(result); &#125;, 1000) &#125;)&#125;func(1).then((result) =&gt; &#123; console.log(result)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 1. Promise 用法 1new Promise((resolve, reject) =&gt; &#123;...&#125;).then(onResolved, onRejected) 任务状态管理： resolve 成功状态，对应 Promise.resolve reject 失败状态，对应 Promise.reject error 异常状态， 对应 Promise.reject 或 new Promise().catch(onRejected) Thenabled机制提供任务方法链： new Promise().then().then().catch() 1.1. Resolve 处理任务的成功状态 1.1.1. 普通方式 12345678let p = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; let result = 1; resolve(result); &#125;, 1000)&#125;)p.then((result)=&gt;&#123; console.log(result) &#125;) 1.1.2. 快捷方式 1234let p = Promise.resolve(1)p.then((result)=&gt;&#123; console.log(result) &#125;) 1.2. Reject 处理任务的失败状态 1.2.1 普通方式 12345678910111213141516171819202122232425262728293031323334let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result = 2; reject(result); &#125;, 100)&#125;)// 有两种方式获取失败状态// 第一种，通过then 第二个函数参数处理失败状态p.then((result)=&gt;&#123; console.log('success:',result);&#125;, (result)=&gt;&#123; console.log('fail:',result);&#125;)// \"fail: 2\"// 第二种，或者通过，catch 获取失败状态p.then((result)=&gt;&#123; console.log('success:',result);&#125;).catch((result)=&gt;&#123; console.log('error:',result);&#125;)// \"error: 2\"// 注意：如果两种方式同时使用的话// 只会被第一种方式reject操作失败的结果p.then((result)=&gt;&#123; console.log('success:',result);&#125;, (result)=&gt;&#123; console.log('fail:',result);&#125;).catch((result)=&gt;&#123; console.log('error:',result);&#125;)// \"fail: 2\" 1.2.2 快捷方式 123456let p = Promise.reject(2)p.then(null, result =&gt; console.log('fail:', result))// 或p.then().catch( result =&gt; console.log('error:', result)) 1.3. Catch 从上述 reject 的使用过程中，会发现, catch操作在没有设置 onRejected 处理的时候，会被catch 捕获失败处理。同时catch 也会捕获 onResolved 和 onRejected中出现的错误。 1.3.1. 正常情况下直接捕获reject结果 1234567891011let p = new Promise((resolve, reject) =&gt; &#123; reject(3)&#125;);p.then((result) =&gt; &#123; console.log('success:', result)&#125;).catch((result) =&gt; &#123; console.log('error:', result)&#125;)// \"error: 3\" 1.3.2. 捕获 onResolved 中错误异常 12345678910111213let p = new Promise((resolve) =&gt; &#123; resolve(3)&#125;);p.then((result) =&gt; &#123; throw new Error('custom resolve error!') console.log('success:', result)&#125;).catch((err) =&gt; &#123; console.log('Custom error:', err)&#125;)// \"Custom error: Error: custom resolve error!\" 1.3.3. 捕获 onRejected 中错误异常 1234567891011let p = new Promise((resolve) =&gt; &#123; reject(3)&#125;);p.then(null, (result) =&gt; &#123; throw new Error('custom reject error!') console.log('fail:', result)&#125;).catch((err) =&gt; &#123; console.log('Custom error:', err)&#125;)// \"Custom error: Error: custom reject error!\"","link":"/2016/07/29/nodejs-promise/"},{"title":"Google 高级搜索","text":"双引号 关键词放在双引号中，代表完全匹配搜索，即返回的网页包含双引号中出现的所有的词，顺序也必须完全匹配。 例如：&quot;搜索 图片&quot; 减号 减号代表搜索不包含减号后面的词的网页。减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。 例如：搜索 -引擎 返回包含 搜索 不包含 引擎 的网页 星号 星号 * 通配符代表任何文字。 例如：搜索*擎 中的 * 号代表任何文字。返回包含 搜索引擎，搜索收擎，搜索巨擎 等内容的网页。 inurl inurl:WORD 搜索关键词出现在url中的网页。 例如：inurl:引擎 返回url中包含 引擎 的网页。 inurl:admin.php allinurl allinurl:WORDS 搜索url中包含多个关键词的网页。 例如：allinurl:搜索 引擎 相当于：inurl:搜索 inurl:引擎。 intitle intitle:WORD 返回title中包含关键词的网页。 例如：intitle:用户登录 返回title包含 用户登录 的网页 allintitle allintitle:WORDS 返回title中包含多个关键词的网页。 例如：allintitle:搜索 引擎 相当于：intitle:搜索 intitle:引擎 intext intext:WORD 返回正文中包含关键词的网页。 例如：intext:用户登录 返回正文包含 用户登录 的网页 allintext allintext:WORDS 返回正文中包含多个关键词的网页。 例如：allintext:搜索 引擎 相当于：intext:搜索 intext:引擎 inanchor inanchor:WORD 返回链接锚点中包含关键词的网页 例如：inanchor:搜索 返回链接锚点中包含 搜索 的网页。 allinanchor allinanchor:WORDS 返回链接锚点中包含多个关键词的网页 例如：allinanchor:搜索 引擎 返回链接锚点中包含 搜索 和 引擎 的网页。 link link:URL 返回链接到目标URL的网页 info info:URL 返回目标URL信息 filetype filetype:TYPE WORD 返回包含关键词的特定文件。 例如：filetype:pdf 搜索 返回包含 搜索 关键词的所有 pdf 文件。 site site:URL 返回某个域名下的所有网页。 例如：site:google.com，site:.google.com related related:URL 返回与某个网站有关联的网页。 cache cache:URL 返回某些已经被删除的死链接网页。 index of / 列出文件（需要服务器支持） 例如：index of /mp3","link":"/2018/07/29/google-search/"},{"title":"任务自动管理工具 Grunt","text":"在前端的开发过程中，经常会遇到一些重复性的任务，比如合并文件、压缩代码、检查语法错误、将Less代码转成CSS代码等等。 通常，我们需要使用不同的工具，来完成不同的任务，既重复劳动又非常耗时。Grunt就是为了解决这个问题而发明的工具，可以帮助我们自动管理和运行各种任务。 简单说，Grunt是一个自动任务运行器，会按照预先设定的顺序自动运行一系列的任务。 这可以简化工作流程，减轻重复性工作带来的负担。 1. 安装 Grunt基于NodeJS，安装之前先确保系统已经安装好NodeJS。 运行下面的命令全局安装Grunt命令行grunt-cli 1npm install -g grunt-cli 注意，安装grunt-cli并不等于安装了Grunt！Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。 2. 初始化 新建一个测试项目 grunt-learn-01，并初始化 12345cd ~/gruntmkdir grunt-learn-01cd grunt-learn-01touch GruntFile.jsnpm init npm init 命令使用交互方式生成 package.json 文件，当然你也可以手动创建。 .├── GruntFile.js└── package.json 通过 npm install 安装Grunt和项目所需的Grunt插件， 注意插件名格式一般都 grunt-contrib-xxx 12345npm install --save grunt # 默认安装最新版本npm install --save grunt-contrib-less # less编译成cssnpm install --save grunt-contrib-uglify # js压缩npm install --save grunt-contrib-concat # 文件合并npm install --save grunt-contrib-watch # 文件监视 3. 配置任务 所有的任务都配置在 package.json 文件在同一目录下的 GruntFile.js 文件中。 GruntFile.js 文件格式如下： 123456789101112131415161718192021222324252627module.exports = function(grunt) &#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), // less 任务（task） less: &#123; // foo 目标（target） foo: &#123; // 任务主体 &#125;, bar: &#123;&#125;, &#125;, uglify: &#123; foo: &#123;&#125; &#125;, concat: &#123;&#125;, watch: &#123;&#125;, &#125;); // 插件列表 grunt.loadNpmTasks('grunt-contrib-less'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-watch'); // 注册任务 grunt.registerTask('default', ['less', 'uglify', 'concat', 'watch']);&#125;; 在上面的案例中，less 任务有名为 foo 和 bar 两个目标，而 uglify 任务仅仅只有一个名为 foo 目标。 grunt less:foo 将执行 less 任务（task）下的 foo 目标（target） grunt less 将执行 less 任务（task）下的所有目标（target） 任务主体有如下四种定义方式： 简洁格式 文件对象格式 文件数组格式动 态构建文件对象格式 3.1. 简洁格式 这种形式允许每个目标对应一个 src-dest 文件映射。 12345678910grunt.initConfig(&#123; less: &#123; // 编译 src/css/ 目录下的 aaa.less 和 bbb.less // 生成到 dest/css/ 目录下 ccc.css foo: &#123; src: ['src/css/aaa.less', 'src/css/bbb.less'], dest: 'dest/css/ccc.css', &#125;, &#125;,&#125;); 3.2. 文件对象格式 这种形式支持每个目标对应多个 src-dest 形式的文件映射， 属性名就是目标文件，源文件就是它的值(源文件列表则使用数组格式声明) 123456789grunt.initConfig(&#123; less: &#123; foo: &#123; files: &#123; 'dest/css/ccc.css': ['src/css/aaa.less', 'src/css/bbb.less'], &#125;, &#125;, &#125;,&#125;); 3.3. 文件数组格式动 这种形式支持每个目标对应多个 src-dest 文件映射，同时允许每个映射拥有额外属性： 123456789101112grunt.initConfig(&#123; less: &#123; foo: &#123; files: [ &#123; src: ['src/css/aaa.less', 'src/css/bbb.less'], dest: 'dest/css/ccc.css', &#125;, ], &#125;, &#125;,&#125;); 3.4. 动态构建文件对象格式 当你希望处理大量的单个文件时，这里有一些附加的属性可以用来动态的构建一个文件列表。 1234567891011121314151617grunt.initConfig(&#123; less: &#123; dynamic_mappings: &#123; files: [ // 匹配 src/css/ 目录及其子目录下的所有后缀为 .less 的文件 // 分别编译生成到 dist/css 目录下，保留目录结构并以 .min.css 为后缀 &#123; expand: true, cwd: 'src/', src: ['css/**/*.less'], dest: 'dist/', ext: '.min.css', &#125;, ], &#125;, &#125;,&#125;); 4. 注册任务 通常多个任务是要依次执行，如： 首先 编译 less然后 压缩 js然后 合并多个文件然后 监听上述文件... 我们可以把相关的任务按自己的业务逻辑进行组织，方便执行。 每当运行Grunt时, 你可以为其指定一个或多个任务, 这些任务用于告诉Grunt你想要它做什么事情。 注册任务有如下两种方式： 别名任务 自定义任务 4.1. 别名任务 别名任务，方便将多个相关任务用一个别名来调用。 12// taskList 是一个数组grunt.registerTask(taskName, [description, ] taskList) 下面的案例中，运行 grunt 时没有指定任何任务，default 别名意指默认。 它将自动依次执行 less、uglify、concat 任务。 1grunt.registerTask('default', ['less', 'uglify', 'concat']); taskList 中也可以以 task:target 形式，指定基本的目标。 下面的案例中，运行 grunt dev 时指定了 dev 别名， 它将自动依次执行 less:dev、uglify:dev 和 concat:dev 任务 1grunt.registerTask('dev', ['less:dev', 'uglify:dev', 'concat:dev']); 4.2. 自定义任务 自定义任务执行时，Grunt并不会检查配置和环境，它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数。 在任务函数里可以调用 Grunt API 执行其它任务，异步执行，自身名称和参数，获取配置... 1grunt.registerTask(taskName, [description, ] taskFunction) 123grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; grunt.log.writeln('Currently running the \"foo\" task.');&#125;); 在一个任务内部，你可以执行其他的任务。 12345678grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; grunt.task.run('bar', 'baz'); // or grunt.task.run(['bar', 'baz']);&#125;);// 等同于grunt.registerTask('foo', 'My \"foo\" task.', ['bar', 'baz']); 任务也可以是异步的。 12345678910111213grunt.registerTask('asyncfoo', 'My \"asyncfoo\" task.', function() &#123; // 进入异步模式并返回 handle 句柄 var done = this.async(); // 异步操作 grunt.log.writeln('Processing task...'); setTimeout(function() &#123; grunt.log.writeln('All done!'); // 异步操作完后执行 handle 句柄 done(); &#125;, 1000);&#125;); 任务也可以访问它们自身名称和参数。 1234567891011grunt.registerTask('foo', 'My \"foo\" task.', function(a, b) &#123; grunt.log.writeln(this.name, a, b);&#125;);// 用法：// grunt foo// logs: \"foo\", undefined, undefined// grunt foo:bar// logs: \"foo\", \"bar\", undefined// grunt foo:bar:baz// logs: \"foo\", \"bar\", \"baz\" 如果记录到任何错误，那么任务就会失败。 12345678910grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; if (failureOfSomeKind) &#123; grunt.log.error('This is an error message.'); &#125; // 如果这个任务出现错误则返回 false if (ifErrors) &#123; return false; &#125; grunt.log.writeln('This is the success message');&#125;); 当任务失败时，所有后续任务都将终止，除非指定 --force 。 12345678910111213// 非异步任务失败 return falsegrunt.registerTask('foo', 'My \"foo\" task.', function() &#123; return false;&#125;);// 异步任务失败 done(false)grunt.registerTask('bar', 'My \"bar\" task.', function() &#123; var done = this.async(); setTimeout(function() &#123; done(false); &#125;, 1000);&#125;); 任务还可以依赖于其他任务的成功执行过。 注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行过，并且没有失败。 1234567891011121314151617grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; return false;&#125;);grunt.registerTask('bar', 'My \"bar\" task.', function() &#123; // 如果 \"foo\" 任务运行失败或者没有运行则任务失败。 grunt.task.requires('foo'); // 如果 \"foo\" 任务运行成功则执行这里的代码。 grunt.log.writeln('Hello, world.');&#125;);// 用法：// grunt foo bar// 没有输出，因为\"foo\"失败。// grunt bar// 没有输出，因为\"foo\"从未运行。 如果任务需要的配置属性不存在，其也可能失败。 123456789grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; // 检查是否存在 meta.name 配置项 grunt.config.requires('meta.name'); // or grunt.config.requires(['meta', 'name']); grunt.log.writeln('This will only log if meta.name is defined in the config.');&#125;); 任务还可以访问配置属性。 12345grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name')); // or grunt.log.writeln('The meta.name property is: ' + grunt.config(['meta', 'name']));&#125;); 5. 参考链接 · The JavaScript Task Runner","link":"/2015/07/21/grunt/"},{"title":"文件同步工具 - rsync","text":"1. rsync 简介 rsync（remote synchronize）是 Liunx/Unix 下的一个远程数据同步工具。它可通过 LAN/WAN 快速同步多台主机间的文件和目录，并适当利用 rsync 算法（差分编码）以减少数据的传输。 rsync 算法并不是每一次都整份传输，而是只传输两个文件的不同部分，因此其传输速度相当快。 除此之外，rsync 可拷贝、显示目录属性，以及拷贝文件，并可选择性的压缩以及递归拷贝。 rsync 的目的是实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步。 2. 安装 无论是服务器端还是客户端都是同一个软件包。 Linux 下安装首先从rsync 官网下载对应的安装包。也可以使用 wget 进行下载，如下： 1wget https://download.samba.org/pub/rsync/rsync-3.1.3.tar.gz 安装包下载完毕后，我们开始解压并安装。如下： 1234tar -zxvf rsync-3.1.3.tar.gzcd rsync-3.1.3./configuremake &amp;&amp; make install 使用 systemd 管理 rsync daemon 1234567891011121314cp ./packaging/systemd/rsync.service /usr/lib/systemd/system/// 修改 rsync.service 如下：// [Unit]// Description=fast remote file copy program daemon// ConditionPathExists=/etc/rsyncd.conf// // [Service]// ExecStart=/usr/local/rsync-3.1.3/bin/rsync --daemon --no-detach// // [Install]// WantedBy=multi-user.targetsystemctl enable rsync rsync 源码安装会把 rsync 默认安装到 /usr/local/ 目录下，可以通过如下命令查看全部编辑选项： 1./configure –help 3. rsync 命令参数 rsync安装完毕后，我们来查看下 rsync 命令的帮助，如下： 1rsync –help 常用参数: 123456789-v, --verbose 详细模式输出-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性不变-z, --compress 对备份的文件在传输时进行压缩处理--exclude 排除不需要传输的文件--exclude-from 从文件中读取排除规则--existing 只更新目标端已存在的文件--ignore-existing 只是更新目标端不存在的文件--remove-source-files 删除 SRC 中已经更新成功的文件--delete：删除 DEST 中存在而在 SRC 中没有的文件 4. rsync 三种工作模式 rsync 的七种基本命令格式如下： 1234567rsync [OPTION]... SRC [SRC]... DESTrsync [OPTION]... SRC [SRC]... [USER@]HOST:DESTrsync [OPTION]... SRC [SRC]... [USER@]HOST::DESTrsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DESTrsync [OPTION]... [USER@]HOST:SRC [DEST]rsync [OPTION]... [USER@]HOST::SRC [DEST]rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 七种基本命令包括三种工作方式： 本地同步模式 远程 shell 模式 rsync daemon 模式 前两者是使用管道进行通信和传输数据的，后者是通过网络套接字进行通信和传输数据的，rsync daemon 模式要求在服务器端必须已经运行好 rsync 且监听在指定端口上。 12345678910111213141516本地同步模式: rsync [OPTION]... SRC [SRC]... DEST远程 shell 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST 拉取: rsync [OPTION]... [USER@]HOST:SRC [DEST]rsync daemon 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST 拉取: rsync [OPTION]... [USER@]HOST::SRC [DEST] rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 第一个路径参数一定是源文件路径，即作为同步基准的一方，可以同时指定多个源文件路径。最后一个路径参数则是目标文件路径，也就是待同步方。 路径的格式可以是本地路径，也可以是使用 user@host:path 或 user@host::path 的远程路径，如果主机和 path 路径之间使用单个冒号隔开，表示使用的是远程 shell 模式，而使用双冒号隔开的则表示的是连接rsync daemon 模式。另外，使用 rsync daemon 模式时，还提供了URL格式的路径表述方式 rsync://user@host/path。 如果仅有一个 SRC 或 DEST 参数，则将以类似于 ls -l 的方式列出源文件列表而不是同步文件。 另外一定要注意的一点是，源路径如果是一个目录的话，带上尾随斜线和不带尾随斜线是不一样的，不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身。例如： 12rsync -a /src /destrsync -a /src/ /dest 第一个命令会在 /dest 目录下创建 src 目录，而第二个命令不会在 /dest 目录下创建 src 目录，源路径 /src/ 中的所有文件都直接放在 /dest 目录下。 5. 本地同步模式 此模式的命令如下： 12本地同步模式: rsync [OPTION]... SRC [SRC]... DEST 1rsync -avz /src /dest 6. 远程 shell 模式 此模式的命令如下： 12345远程 shell 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST 拉取: rsync [OPTION]... [USER@]HOST:SRC [DEST] 1234推送: rsync -avz -e \"ssh -p 22\" /src user@192.168.199.247:/dest拉取: rsync -avz -e \"ssh -p 22\" user@192.168.199.247:/src /dest 7. rsync daemon 模式 此模式的命令如下： 1234567rsync daemon 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST 拉取: rsync [OPTION]... [USER@]HOST::SRC [DEST] rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 连接命令有两种类型： 一种是 rsync 风格使用双冒号的 [USER@]HOST::TARGET，如果想要指定端口号，则需要使用选项 --port。 一种是 url 风格的 rsync://[USER@]HOST[:PORT]/TARGET 上述语法中，其中 TARGET 代表的是模块名，而不是真的文件系统中的路径。 7.1. rsyncd.conf 配置文件 参见官方的配置说明了解全部配置项。 在服务器端启动 rsync daemon 的命令为 rsync --daemon，可能通过 rsync --daemon --help 查看其选项。 服务器端需要两个配置文件：rsyncd.conf 和 rsyncd.secrets。 rsyncd.conf 是 rsync daemon 的主配置文件，rsyncd.secrets 用于存储 rsync 用户名和密码。 MacOS 下默认配置文件为 /usr/local/etc/rsyncd.conf Linux 下默认配置文件为 etc/rsyncd.conf 如果文件不存在，可以手动创建，也可以通过 --config=FILE 选项来指定。 rsyncd.conf 配置实例： 12345678910111213141516171819202122232425262728# 全屏配置port = 873 # rsync 端口，默认873uid = rootgid = rootuser chroot = nomax connections = 200 # 0 表示没有限制timeout = 600 # 0 表示永远等待pid file = /var/run/rsyncd.pidlock file = /var/run/rsyncd.locklog file = /var/run/rsyncd.log# 模块配置[www] # 模块IDpath = /var/www/ # 模块路径uid = www # 模块路径的最终所属用户名gid = www # 模块路径的最终所属用户组ignore errorsread only = no # yes：不能上传，no：能上传write only = no # yes：不能下载，no：能下载list = yes # 客户端请求显示模块列表时，该模块是否显示出来hosts allow = 10.0.0.0/24 # 指定允许连接到该模块的机器，多个用空格隔开hosts deny = 0.0.0.0/32 # 指定不允许连接到该模块的机器auth users = rsync_www # 指定允许链接到该模块的用户名列表，多个用空格隔开secrets file = /etc/rsyncd.secrets # 指定一个包含定义用户名:密码对的文件comment = rsync deamon www module # 模块描述# 其它模块# ... 7.2. rsyncd.secrets 格式 文件的权限一定要是600，否则客户端将不能连接服务器 12user:passworduser1:password1 7.3. 测试 服务端： 123456789useradd -r -s /sbin/nologin wwwmkdir /var/wwwchown -R www:www /var/wwwecho \"rsync_www:123456\" &gt;&gt; /etc/rsyncd.secretschmod 600 /etc/rsyncd.secrets// rsync --deamonsystemctl start rsync 客户端： 1234567891011121314useradd -r -s /sbin/nologin wwwmkdir /var/wwwtouch /var/www/01.txtchown -R www:www /var/wwwecho \"123456\" &gt;&gt; /etc/rsyncd.secretschmod 600 /etc/rsyncd.secretscd /var/www# 列表服务端文件rsync rsync_www@172.17.0.2::www --password-file=/etc/rsyncd.secrets# 上传rsync -avz ./ rsync_www@172.17.0.2::www --password-file=/etc/rsyncd.secrets 8. 参考链接 · rsync · rsyncd.conf man page","link":"/2016/01/04/rsync/"},{"title":"使用 Markdown-it 渲染 Hexo","text":"Hexo 默认其官方插件 hexo-renderer-marked 使用 marked 来渲染 Markdown。后来发现这个插件有很多特殊 Markdown 语法不支持。 一番查找后发现 Hexo 官方还有另一个使用 markdown-it 做渲染器的插件 hexo-renderer-markdown-it。该渲染器有众多插件可以用来处理诸如： 缩写 markdown-it-abbr 脚注 markdown-it-footnote &lt;ins&gt; markdown-it-ins 下标 markdown-it-sub 上标 markdown-it-sup 锚点 markdown-it-anchor &lt;dl&gt; markdown-it-deflist &lt;mark&gt; markdown-it-mark 自定义容器 markdown-it-container 表情 markdown-it-emoji HTML 属性 markdown-it-attrs Task Lists markdown-it-task-lists 其它... 1. 安装 进入你的 hexo 的根目录，先删除默认渲染器插件，再安装 hexo-renderer-markdown-it 123456cd myhexoblog/npm uninstall hexo-renderer-marked# npm install --save hexo-renderer-markdown-it# 直接从 GitHub 上安装，支持配置插件npm install --save git+https://github.com/hexojs/hexo-renderer-markdown-it.git 2. 配置 _config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: # Enable HTML tags in source html: true # Use '/' to close single tags (&lt;br /&gt;). This is only for full CommonMark compatibility. xhtmlOut: true # Convert '\\n' in paragraphs into &lt;br&gt; breaks: true # CSS language prefix for fenced blocks. Can be useful for external highlighters. langPrefix: 'language-' # Autoconvert URL-like text to links linkify: true # Enable some language-neutral replacement + quotes beautification typographer: false # Double + single quotes replacement pairs, when typographer enabled, # and smartquotes on. Could be either a String or an Array. # # For example, you can use '«»„“' for Russian, '„“‚‘' for German, # and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp). quotes: '“”‘’' # Plugins plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-anchor - markdown-it-deflist - markdown-it-mark - markdown-it-container - markdown-it-emoji - markdown-it-attrs - name: markdown-it-task-lists options: enabled: false label: true labelAfter: false # Automatic Headline ID's anchors: # Minimum level for ID creation. (Ex. h2 to h6) level: 2 # A suffix that is prepended to the number given if the ID is repeated. collisionSuffix: 'v' # If `true`, creates an anchor tag with a permalink besides the heading. permalink: false # Class used for the permalink anchor tag. permalinkClass: header-anchor # The symbol used to make the permalink permalinkSymbol: ¶ 3. 安装插件 12345678910111213npm install --save markdown-it-abbrnpm install --save markdown-it-footnotenpm install --save markdown-it-insnpm install --save markdown-it-subnpm install --save markdown-it-supnpm install --save markdown-it-anchornpm install --save markdown-it-deflistnpm install --save markdown-it-marknpm install --save markdown-it-containernpm install --save markdown-it-emojinpm install --save markdown-it-attrsnpm install --save markdown-it-task-lists 4. 示例 至此我们已经安装并配置好新的渲染器，运行如下命令使其生效： 12hexo cleanhexo server -p 4000 4.1. Task List markdown-it-task-lists 用来渲染 GitHub 风格的 Task List。 1234567...- name: markdown-it-task-lists options: enabled: false label: true labelAfter: false... 12345678910###### Task List- [ ] Mercury- [x] Venus- [x] Earth (Orbit/Moon)- [x] Mars- [ ] Jupiter- [ ] Saturn- [ ] Uranus- [ ] Neptune- [ ] Comet Haley Task List Mercury Venus Earth (Orbit/Moon) Mars Jupiter Saturn Uranus Neptune Comet Haley 4.1. 表情 Emoji 4.1.1. EmojiCopy 在 EmojiCopy 中找到你想要的表情，然后点击即可复制粘贴。 😦 😊 😕 4.1.2. Emoji Cheat Sheet 参见 markdown-it-emoji definitions。 1:frowning: :blush: :confused: 4.1.3. 缩写格式（shortcuts） 参见 markdown-it-emoji shortcuts。 1&gt;:( :\") :/ 注：上述三种方式同时可以结合 markdown-it-attrs 插件添加 style 或者 classname 修改表情大小。 1234567891011😦 😊 😕&#123;style=\"font-size:2rem;\"&#125;😦 😊 😕&#123;.h2&#125;:frowning: :blush: :confused:&#123;.h2&#125;&gt;:( :\") :/&#123;.h2&#125; 4.1.4. Twemoji 上述三种方式都是输出 Unicode 字符表情，通过 Twemoji 可以输出图片格式的表情。 实际上 markdown-it-attrs 可以通过 md.renderer.rules.emoji 来设置渲染输出处理机制，默认是直接输出。只需要修改这个地方就能满足要求。 首先需要安装 twemoji 包： 1npm install --save twemoji 然后修改如下代码： node_modules/markdown-it-emoji/index.js1234567891011...var twemoji = require('twemoji') // md.renderer.rules.emoji = emoji_html;md.renderer.rules.emoji = function(token, idx) &#123; return twemoji.parse(token[idx].content, &#123; // options // https://github.com/twitter/twemoji &#125;);&#125;;... Twemoji 可以输出 svg 格式的图片，要修改表情图片的大小，只能在 Css 中修改。 123456.emoji &#123; height: 1.5em; width: 1.5em; margin: 0 .05em 0 .1em; vertical-align: -0.1em;&#125; 5. 参考链接 · hexo-renderer-marked · hexo-renderer-markdown-it · Emoji Cheat Sheet · Github Emojis API · Twemoji · EmojiCopy","link":"/2016/06/25/hexo-render/"},{"title":"Linux 系统服务管理器 - Systemd","text":"Systemd 是 linux 系统中最新的初始化系统，大多数主流发行版要么已经采用 Systemd，要么即将在下个发布中采用。Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 Systemd 取代了 initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。 查看 CentOS7 下的 /etc/init.d/ 会发现只有一个 README 文件。 123456cat /etc/init.d/README// ...// You are running a systemd-based OS where traditional init scripts have// been replaced by native systemd services files.// ... 1. 单元 Unit Unit 是 systemd 进行任务管理的基本单位，代表所有系统能够处理的资源，这些资源通过配置文件的方式提供给 Systemd 管理。目前 Unit 有如下类型： .service 系统服务 .socket Sockets .device 系统设备 .mount 挂载点 .automount 自动挂载点 .swap 交换分区 .target 启动目标 .path 文件路径 .timer 定时器 .snapshot Systemd 快照，可以切回某个快照 .slice 进程组 .scope 从 Systemd 外部创建的进程 systemctl list-units 命令可以查看当前系统的所有 Unit 1234567891011121314# 列出正在运行的 Unitsystemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的systemctl list-units --all# 列出所有没有运行的 Unitsystemctl list-units --all --state=inactive# 列出所有加载失败的 Unitsystemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unitsystemctl list-units --type=service 1.1. Unit 的状态 systemctl status 命令用于查看系统状态和单个 Unit 的状态 1234567891011121314# 显示系统状态systemctl status# 显示单个 Unit 的状态sysystemctl status rsync.service# 显示 Unit 是否正在运行systemctl is-active rsync.service# 显示 Unit 是否处于启动失败状态systemctl is-failed rsync.service# 显示 Unit 服务是否建立了启动链接systemctl is-enabled rsync.service 1.2. 管理 Unit 对于用户来说，最常用的是下面 Util 管理命令。 1234567891011121314151617181920212223242526272829303132333435363738# 显示单元的手册页（必须由单元文件提供）：systemctl help rsync.service# 立即启动一个服务systemctl start rsync.service# 立即停止一个服务systemctl stop rsync.service# 重启一个服务systemctl restart rsync.service# 杀死一个服务的所有子进程systemctl kill rsync.service# 重新加载一个服务的配置文件systemctl reload rsync.service# 重载所有修改过的配置文件systemctl daemon-reload# 显示 Unit 配置文件systemctl cat rsync.service# 编辑 Unit 主配置文件，并重新加载systemctl edit --full rsync.service# 编辑 Unit 子配置文件，并重新加载systemctl edit rsync.service# 显示 Unit 的所有底层参数systemctl show rsync.service# 显示 Unit 的指定属性的值systemctl show -p CPUShares rsync.service# 设置某个 Unit 的指定属性systemctl set-property rsync.service CPUShares=500 1.3. 依赖关系 使用 systemd 时，可通过正确编写单元配置文件来解决其依赖关系。典型的情况是，单元 A 要求单元 B 在 A 启动之前运行。在此情况下，向单元 A 配置文件中的 [Unit] 段添加 Requires=B 和 After=B 即可。若此依赖关系是可选的，可添加 Wants=B 和 After=B 。请注意 Wants= 和 Requires= 并不意味着 After= ，即如果 After= 选项没有制定，这两个单元将被并行启动。 systemctl list-dependencies 命令列出一个 Unit 的所有依赖。 1systemctl list-dependencies rsync.service 上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用 --all 参数。 1systemctl list-dependencies --all rsync.service 2. Unit 的配置文件 每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit。 systemctl show --property=UnitPath 查看按优先级从低到高显示加载目录 默认最先加载 /etc/systemd/system/ 目录下的 Util。 1234# 激活一个 Utilsystemctl enable rsync.service# 禁止一个 Utilsystemctl disable rsync.service 2.1. 配置文件的状态 systemctl list-unit-files 命令用于列出所有配置文件。 1234# 列出所有配置文件systemctl list-unit-files# 列出指定类型的配置文件systemctl list-unit-files --type=service 这个列表显示每个配置文件的状态，一共有四种: enabled 已建立启动链接 disabled 没建立启动链接 static 该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖 masked 该配置文件被禁止建立启动链接 2.2. 配置文件的格式 systemctl cat 命令可以查看配置文件的内容。 1234567891011systemctl cat rsync.service[Unit]Description=fast remote file copy program daemonConditionPathExists=/etc/rsyncd.conf[Service]ExecStart=/usr/local/rsync-3.1.3/bin/rsync --daemon --no-detach[Install]WantedBy=multi-user.target 可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。 每个区块内部是一些等号连接的键值对，键值对的等号两侧不能有空格。 以 # 开头的注释可能也能用在 unit-files 中，但是只能在新行中使用。不要在 systemd 的参数后面使用行末注释，否则 unit 将会启动失败。 1234[Section]Directive1=valueDirective2=value. . . 2.3. 配置文件的区块 [Unit] 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下： Description：简短描述Documentation：文档地址Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行Condition...：当前 Unit 运行必须满足的条件，否则不会运行Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败 [Install] 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下： WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中Alias：当前 Unit 可用于启动的别名Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit [Service] 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下： Type：定义启动时的进程行为。它有以下几种值。Type=simple：默认值，执行ExecStart指定的命令，启动主进程Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行Type=dbus：当前服务通过D-Bus启动Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行Type=idle：若有其他任务执行完毕，当前服务才会运行ExecStart：启动当前服务的命令ExecStartPre：启动当前服务之前执行的命令ExecStartPost：启动当前服务之后执行的命令ExecReload：重启当前服务时执行的命令ExecStop：停止当前服务时执行的命令ExecStopPost：停止当其服务之后执行的命令RestartSec：自动重启当前服务间隔的秒数Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdogTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数Environment：指定环境变量 Unit 配置文件的完整字段清单，请参考官方文档。 2.4. 修改现存单元文件 2.4.1. 直接修改了源配置文件 修改后需要 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。 12systemctl daemon-reloadsystemctl restart rsync.service 2.4.2. 直接编辑并加载 1systemctl edit --full rsync.service 2.4.3. 添加子配置并加载 如下命令会创建 /etc/systemd/system/rsync.service.d/override.conf 文件用来覆盖 /etc/systemd/system/rsync.service 中的配置。 1systemctl edit rsync.service 3. Target Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。 传统的 init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 12345678910111213141516# 查看当前系统的所有 Targetsystemctl list-unit-files --type=target# 查看一个 Target 包含的所有 Unitsystemctl list-dependencies multi-user.target# 查看启动时的默认 Targetsystemctl get-default# 设置启动时的默认 Targetsystemctl set-default multi-user.target# 切换 Target 时，默认不关闭前一个 Target 启动的进程，# systemctl isolate 命令改变这种行为，# 关闭前一个 Target 里面所有不属于后一个 Target 的进程systemctl isolate multi-user.target Target 与 传统 RunLevel 的对应关系如下。 Traditional runlevel New target name Symbolically linked to...Runlevel 0 | runlevel0.target -&gt; poweroff.targetRunlevel 1 | runlevel1.target -&gt; rescue.targetRunlevel 2 | runlevel2.target -&gt; multi-user.targetRunlevel 3 | runlevel3.target -&gt; multi-user.targetRunlevel 4 | runlevel4.target -&gt; multi-user.targetRunlevel 5 | runlevel5.target -&gt; graphical.targetRunlevel 6 | runlevel6.target -&gt; reboot.target 4.日志管理 Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf。 journalctl 用法如下： # 查看所有日志（默认情况下 ，只保存本次启动的日志）journalctl# 查看内核日志（不显示应用日志）journalctl -k# 查看系统本次启动的日志journalctl -bjournalctl -b -0# 查看上一次启动的日志（需更改设置）journalctl -b -1# 查看指定时间的日志journalctl --since=\"2012-10-30 18:17:16\"journalctl --since \"20 min ago\"journalctl --since yesterdayjournalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"journalctl --since 09:00 --until \"1 hour ago\"# 显示尾部的最新10行日志journalctl -n# 显示尾部指定行数的日志journalctl -n 20# 实时滚动显示最新日志journalctl -f# 查看指定服务的日志journalctl /usr/lib/systemd/systemd# 查看指定进程的日志journalctl _PID=1# 查看某个路径的脚本的日志journalctl /usr/bin/bash# 查看指定用户的日志journalctl _UID=33 --since today# 查看某个 Unit 的日志journalctl -u rsync.servicejournalctl -u rsync.service --since today# 实时滚动显示 Unit 的最新日志journalctl -u rsync.service -f# 合并显示多个 Unit 的日志journalctl -u rsync.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debugjournalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出journalctl --no-pager# 以 JSON 格式（单行）输出journalctl -b -u rsync.service -o json# 以 JSON 格式（多行）输出，可读性更好journalctl -b -u rsync.serviceqq -o json-pretty# 显示日志占据的硬盘空间journalctl --disk-usage# 指定日志文件占据的最大空间journalctl --vacuum-size=1G# 指定日志文件保存多久journalctl --vacuum-time=1years 5. 系统管理命令 5.1. systemctl systemctl 是 Systemd 的主命令，用于管理系统。 1234567891011121314151617181920212223# 命令查看 Systemd 的版本systemctl --version# 重启systemctl reboot# 退出系统并关闭电源systemctl poweroff# CPU停止工作systemctl halt# 待机systemctl suspend# 休眠systemctl hibernate# 休眠并待机systemctl hybrid-sleep# 启动进入救援模式systemctl rescue 5.2. systemd-analyze systemd-analyze 命令用于查看启动耗时。 1234567891011# 查看启动耗时systemd-analyze # 查看每个服务的启动耗时systemd-analyze blame# 显示瀑布状的启动过程流systemd-analyze critical-chain# 显示指定服务的启动流systemd-analyze critical-chain atd.service 5.3. hostnamectl hostnamectl 命令用于查看本地化设置。 12345# 显示当前主机的信息hostnamectl# 设置主机名。hostnamectl set-hostname rhel7 5.4. localectl localectl 命令用于查看本地化设置。 123456# 查看本地化设置localectl# 设置本地化参数。localectl set-locale LANG=en_GB.utf8localectl set-keymap en_GB 5.5. timedatectl timedatectl 命令用于查看当前时区设置。 12345678910# 查看当前时区设置timedatectl# 显示所有可用的时区timedatectl list-timezones # 设置当前时区timedatectl set-timezone America/New_Yorktimedatectl set-time YYYY-MM-DDtimedatectl set-time HH:MM:SS 5.6. loginctl loginctl 命令用于查看当前登录的用户。 12345678# 列出当前sessionloginctl list-sessions# 列出当前登录用户loginctl list-users# 列出显示指定用户的信息loginctl show-user root 6. 参考链接 · Systemd GitHub · Systemd Office Site · Systemd Unit Man · How To Use Systemd · Archlinux Systemd","link":"/2016/03/24/systemd/"}],"tags":[{"name":"日志","slug":"日志","link":"/tags/日志/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Gif","slug":"Gif","link":"/tags/Gif/"},{"name":"Kap","slug":"Kap","link":"/tags/Kap/"},{"name":"Nvm","slug":"Nvm","link":"/tags/Nvm/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Systemd","slug":"Systemd","link":"/tags/Systemd/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Grunt","slug":"Grunt","link":"/tags/Grunt/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Rsync","slug":"Rsync","link":"/tags/Rsync/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Emoji","slug":"Emoji","link":"/tags/Emoji/"}],"categories":[{"name":"日志","slug":"日志","link":"/categories/日志/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"VS Code","slug":"VS-Code","link":"/categories/VS-Code/"},{"name":"MacOS","slug":"MacOS","link":"/categories/MacOS/"},{"name":"Node.Js","slug":"Node-Js","link":"/categories/Node-Js/"},{"name":"Hexo","slug":"NodeJS/Hexo","link":"/categories/NodeJS/Hexo/"},{"name":"Systemd","slug":"Linux/Systemd","link":"/categories/Linux/Systemd/"},{"name":"Promise","slug":"NodeJS/Promise","link":"/categories/NodeJS/Promise/"},{"name":"Grunt","slug":"Grunt","link":"/categories/Grunt/"},{"name":"Markdown","slug":"NodeJS/Hexo/Markdown","link":"/categories/NodeJS/Hexo/Markdown/"}]}