{"pages":[{"title":"about","text":"写在最前面！ 折腾 折腾 折腾 一直在折腾。 芳华落尽，风轻云淡。 默然回首才发现什么都没有改变，什么都没有留下。 去他妈的。 我要在这里安家。 The smaller the mind, the greater the conceit. 思想越狭隘，自负越膨胀。","link":"/about/index.html"},{"title":"404","text":"","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"写在最前面！","text":"写在最前面！ 折腾 折腾 折腾 一直在折腾。 芳华落尽，风轻云淡。 默然回首才发现什么都没有改变，什么都没有留下。 去他妈的。 我要在这里安家。 The smaller the mind, the greater the conceit. 思想越狭隘，自负越膨胀。","link":"/2015/07/17/genesis/"},{"title":"Blog 主题功能演示","text":"1. 代码块 12345678910111213141516#!/bin/bash###### CONFIGACCEPTED_HOSTS=\"/root/.hag_accepted.conf\"BE_VERBOSE=falseif [ \"$UID\" -ne 0 ]then echo \"Superuser rights required\" exit 2figenApacheConf()&#123; echo -e \"# Host $&#123;HOME_DIR&#125;$1/$2 :\"&#125; 2. 相册 3. 用户输入 To switch directories, type cd followed by the name of the directory. To edit settings, press ctrl + , 4. 行内代码块 For example, &lt;section&gt; should be wrapped as inline.","link":"/2015/07/19/demo/"},{"title":"使用 Hexo 创建博客","text":"了解过的静态博客框架有 Hexo，Jekyll，Hugo 几种。 Hexo 基于 NodeJS Jekyll 基于 Ruby，由 Github 开发用来服务于 GitHub pages Hugo 基于 Go 静态站点框架的基本思路是本地创建然后生成静态页面后部署到服务器上。 这样做的好处是服务器不需要做类似页面处理，数据库处理之类的工作，只需要发送 Html, css, js, image... 1. 安装 Hexo 基于 NodeJS，安装之前先确保系统已经安装好 NodeJS。 1npm install -g hexo-cli 2. 初始化 全局安装好 Hexo CLI 后， 新建一个测试项目 hexo-learn-01，并初始化 12345cd ~/hexomkdir hexo-learn-01cd hexo-learn-01hexo init ./npm install 初始化后，Hexo 执行 tree -L 2 -I 'node_modules' ./ 查看： ./├── _config.yml # yml 配置文件├── package-lock.json ├── package.json # npm 包管理文件├── scaffolds # 新建文章时的模版文件│ ├── draft.md│ ├── page.md│ └── post.md├── source # 文章&amp;页面目录│ └── _posts└── themes # 主题目录 └── landscape5 directories, 6 files 3. 使用 hexo 命令： Usage: hexo &lt;command&gt;Commands: clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information.Global Options: --config Specify config file instead of using _config.yml --cwd Specify the CWD --debug Display all verbose messages in the terminal --draft Display draft posts --safe Disable all plugins and scripts --silent Hide output on consoleFor more help, you can use 'hexo help [command]' for the detailed informationor you can check the docs: http://hexo.io/docs/ 4. 本地运行 1hexo server 启动后打开浏览器，访问 http://localhost:4000/ &nbsp; 5. 新建文章 1hexo new post 'my first post' hexo 会在 source/_posts/ 目录下生成 my-first-post.md 文件。 hexo 使用 MarkDown 文件格式来编写文章， 修改 my-first-post.md 如下： 12345678910---title: My first postdate: 2018-07-20 16:58:59tags:---This is my first post.blabla...blabla...blabla... 刷新浏览器，将看到我们新添加的文章。 &nbsp; 6. 发布 Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 我们以发布到 GitHub 上为例： 注：每次添加文章和修改文章后，都要发布一次。 在 GitHub 上新建一个 Repository 名字 hexo.learn.01 &nbsp; &nbsp; 首先需要安装 hexo-deployer-git 插件 1npm install hexo-deployer-git 然后修改 _config.yml 配置 注：请将如下配置替换成自己的 12345678...url: https://garryshield.github.ioroot: /hexo.learn.01/...deploy: - type: git repo: git@github.com:garryshield/hexo.learn.01.git ... 执行： 1hexo deploy 发布过程会有点慢，成功会提示 To github.com:garryshield/hexo.learn.01.git * [new branch] HEAD -&gt; gh-pagesBranch 'master' set up to track remote branch 'gh-pages' from 'git@github.com:garryshield/hexo.learn.01.git'.INFO Deploy done: git 浏览器打开 https://garryshield.github.io/hexo.learn.01/ 就能看到已经发布成功了。 &nbsp; 7. 参考链接 · Hexo blog framework","link":"/2015/08/24/hexo/"},{"title":"Linux 命令 - tree","text":"Linux tree 命令用于以树状图列出目录的内容。 执行 tree 指令，它会列出指定目录下的所有文件，包括子目录里的文件。 1. 常用 123456-a 所有文件包括隐藏文件-d 只显示目录-L level 只显示第几级-P pattern 只显示匹配的文件-I pattern 不显示匹配的文件-o filename 输出到文件，而不是 stdout 2. 实例 2.1. 层级 12// 列出目录 ./ 第一级文件名tree -L 1 ./ ./├── _config.yml├── node_modules├── package-lock.json├── package.json├── scaffolds├── source└── themes4 directories, 3 files 2.2. 过滤 12// 列出目录 ./ 第一级下【后缀为 .json 的文件和目录】及【其它】tree -P '*.json' -L 1 ./ // _config.yml 文件被过滤./├── node_modules├── package-lock.json├── package.json├── scaffolds├── source└── themes4 directories, 2 files 2.3. 筛选 12// 列出目录 ./ 第一级下除了 node_modules 的文件tree -I 'node_modules' -L 1 ./ // node_modules 目录被过滤./├── _config.yml├── package-lock.json├── package.json├── scaffolds├── source└── themes3 directories, 3 files 3. 语法 usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ] [-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version] [--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst] [--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;] [--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;] ------- Listing options ------- -a All files are listed. -d List directories only. -l Follow symbolic links like directories. -f Print the full path prefix for each file. -x Stay on current filesystem only. -L level Descend only level directories deep. -R Rerun tree when max dir level reached. -P pattern List only those files that match the pattern given. -I pattern Do not list files that match the given pattern. --ignore-case Ignore case when pattern matching. --matchdirs Include directory names in -P pattern matching. --noreport Turn off file/directory count at end of tree listing. --charset X Use charset X for terminal/HTML and indentation line output. --filelimit # Do not descend dirs with more than # files in them. --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;. -o filename Output to file instead of stdout. -------- File options --------- -q Print non-printable characters as '?'. -N Print non-printable characters as is. -Q Quote filenames with double quotes. -p Print the protections for each file. -u Displays file owner or UID number. -g Displays file group owner or GID number. -s Print the size in bytes of each file. -h Print the size in a more human readable way. --si Like -h, but use in SI units (powers of 1000). -D Print the date of last modification or (-c) status change. -F Appends '/', '=', '*', '@', '|' or '&gt;' as per ls -F. --inodes Print inode number of each file. --device Print device ID number to which each file belongs. ------- Sorting options ------- -v Sort files alphanumerically by version. -t Sort files by last modification time. -c Sort files by last status change time. -U Leave files unsorted. -r Reverse the order of the sort. --dirsfirst List directories before files (-U disables). --sort X Select sort: name,version,size,mtime,ctime. ------- Graphics options ------ -i Don't print indentation lines. -A Print ANSI lines graphic indentation lines. -S Print with CP437 (console) graphics indentation lines. -n Turn colorization off always (-C overrides). -C Turn colorization on always. ------- XML/HTML/JSON options ------- -X Prints out an XML representation of the tree. -J Prints out an JSON representation of the tree. -H baseHREF Prints out HTML format with baseHREF as top directory. -T string Replace the default HTML title and H1 header with string. --nolinks Turn off hyperlinks in HTML output. ---- Miscellaneous options ---- --version Print version and exit. --help Print usage and this help message and exit. -- Options processing terminator.","link":"/2015/08/24/linux-cmd-tree/"},{"title":"VS Code 创建代码片段","text":"Snippet 即代码段，指的是能够帮助输入重复代码模式，比如循环或条件语句的模板。 通过 Snippet 我们仅仅输入一小段字符串「prefix」，就可以在代码段引擎的帮助下，生成预定义的模板代码，接着我们还可以通过在预定义的光标位置之间跳转，来快速补全模板。 当然，看图更易懂。下图将 aja 补全为 JQuery 的 ajax() 方法，并通过光标的跳转，快速补全了待填键值对： &nbsp; 1. Snippet 配置流程 进入 Snippet 设置文件，这里提供了三种方法： 通过快捷键「Shift + Command + P」打开命令窗口（All Command Window），输入snippet，点选「首选项：配置用户代码段片段」。 点击界面最左侧竖栏（也即活动栏）最下方的齿轮按钮，在弹出来的菜单中点选「用户代码片段」。 下「Alt」键切换菜单栏，通过文件 &gt; 首选项 &gt; 用户代码片段。 2. Snippet 详细介绍 设置文件头部的一个块注释给出了设置 Snippet 的格式 1234567891011&#123; \"Print to console\": &#123; \"prefix\": \"log\", \"body\": [ \"console.log('$1');\", \"$2\" ], \"description\": \"Log output to console\" &#125;, ...&#125; Snippet 由三部分组成： prefix：前缀，定义了 Snippet 关键字; body： 主体，即模板的主体内容，其中每个字符串表示一行; description：说明，候选栏中出现。未定义的情况下直接显示对象名，上例中将会显示 Print to console。 2.1. Snippet 主体 主体部分可以使用特殊语法结构，来控制光标和要插入的文本。支持的基本结构如下： 2.1.1. Tabstops：制表符 「Tabstops」可以让编辑器的指针在 Snippet 内跳转。 使用 $1，$2 等指定光标位置。这些数字指定了光标跳转的顺序。 $0 表示最终光标位置。相同序号的「Tabstops」被链接在一起，将会同步更新 2.1.2. Placeholders：占位符 「Placeholder」是带有默认值的「Tabstops」。 如 ${1:Placeholder}。「placeholder」文本将被插入「Tabstops」位置，并在跳转时被全选，以方便修改。 2.1.3. Choice：可选项 「Choice」是提供可选值的「Placeholder」。 语法为一系列用逗号隔开，并最终被两个竖线圈起来的枚举值， 比如 ${1|one,two,three|}。当光标跳转到该位置的时候，用户将会被提供多个值 [one, two, three] 以供选择。 2.1.4. Variables：变量 使用 $name 或 ${name:Placeholder} 可以插入变量的值。 当变量未赋值时，将插入其缺省值或空字符串。 当变量未知时，将插入变量的名称，并将其转换为「Placeholder」。 文件&amp;内容相关变量： TM_SELECTED_TEXT 选中的文本 TM_CURRENT_LINE 行内容 TM_CURRENT_WORD 光标所在的单词 TM_LINE_INDEX 行号（0为基） TM_LINE_NUMBER 行号（1为基） TM_FILENAME 文件名 TM_FILENAME_BASE 文件名无后缀 TM_DIRECTORY 文件所在目录 TM_FILEPATH 文件路径 CLIPBOARD 剪贴板内容 时间相关的变量： CURRENT_YEAR 年 CURRENT_YEAR_SHORT 年（两位） CURRENT_MONTH 月（两位），如 02； CURRENT_MONTH_NAME 月份的全称，如 July； CURRENT_MONTH_NAME_SHORT 月份的简称，如 Jul； CURRENT_DATE 月份第几天 CURRENT_DAY_NAME 周，如 Monday； CURRENT_DAY_NAME_SHORT 周简称，如 Mon； CURRENT_HOUR 时 CURRENT_MINUTE 分 CURRENT_SECOND 秒 3. 参考链接 · VS Code · Creating your own snippets","link":"/2015/09/12/vscode-snippets/"},{"title":"MacOS 开源的录屏工具 - Kap","text":"Kap 是一个开源的录屏工具，支持导出 GIF，MP4，WebM，APNG。同时可以自己编写插件用来分享，转化... 官网： Kap GitHub 网址： Kap GitHub 1. 安装 1.1. 通过 brew 安装 12brew updatebrew cask install kap 1.2. 直接下载安装 下载最新版本 Kap Download 或者到 Kap Releases 页面下载其它版本。 2. 使用 2.1. 选择录制区域 启动后 Kap 会常驻在系统状态栏上。打开面板后看到一个红色按钮。点击它就可以在屏幕上进行录制区域的框选。 &nbsp; 框定的区域会用虚线标识出来，如果想要调整录制区域可以使用鼠标进行拖拽、拉伸来调整。 &nbsp; 要录制全屏或者指定窗口也可以直接选择。 &nbsp; 2.2. 录制 选择录制区域后，再次点击红色按钮，等到系统状态栏上的 Kap 图标变成实心后就进入录制模式。 &nbsp; 要结束录制只需要再次点击系统状态栏上的 Kap 图标，Kap 将打开录制结果窗口。 通过下方的导航，可以导出不同的格式。如果录制结果不理想，关闭本窗口从新录制即可。 &nbsp; 3. 设置 通过快捷键「Command + ‘」进入设置界面。 常用的设置项目： Save To 导出时存放目录 Start automatically 开机自动启动 Show mouse cursor 同时录制鼠标的移动 Keyboard shortcut to record 开启「Command + Shift + F5」快捷键 插件标签下按需求开启所需的插件，有兴趣按自己按官方说明自己扫插件 &nbsp; 4. 参考链接 · Kap Screen Recorder","link":"/2015/10/05/mac-tool-kap/"},{"title":"使用 Nvm 管理 NodeJS","text":"同时开发多个项目，项目的需求不同，进而依赖不同版本的 NodeJS 运行环境。nvm 版本管理工具能够很方便的切换，而不用每次全局修改。 1. 安装 &amp; 更新 建议先删除系统安装的 node 和 npm，完全使用 nvm 来管理。 以 MacOS 为例： 123456brew uninstall node; // or `brew uninstall --force node` which removes all versionsbrew prune;rm -rf /opt/local/bin/node /opt/local/include/node /opt/local/lib/node_modulesrm -rf /usr/local/bin/npm /usr/local/share/man/man1/node.1 /usr/local/lib/dtrace/node.drm -rf ~/.npm ~/.npmrc ~/.node-gyp 安装 &amp; 升级 nvm 123curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash// orwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash 2. 使用 2.1. 下载 &amp; 安装 注：写文章时最新版本是 v10.7.0，最新稳定版本是 v8.11.3。 1234567891011121314151617181920212223242526// 安装最新版 nodenvm install node// 安装稳定（LTS）版本nvm install --lts// nvm 遵守语义化版本命名规则。例如，你想安装 v10.7.0，可以运行：nvm install 10// 安装 v8.11.3 并同时安装 v10.7.0 下已安装的包nvm install 8 --reinstall-packages-from=10// 如果已经安装过 v8.11.3 则下面两行实现同样的效果nvm use 8nvm reinstall-packages 10// 安装 v8.11.3 后同时升级到最新的 npmnvm install 8 --latest-npm// 如果已经安装过 v8.11.3 则下面两行实现同样的效果nvm use 8nvm install-latest-npm// 下面两行实现同样的效果nvm use 8npm install -g npm 2.2. 查看指定版本路径 12345678nvm which current// ~/.nvm/versions/node/v10.7.0/bin/nodenvm which 10// ~/.nvm/versions/node/v10.7.0/bin/nodenvm which 8// ~/.nvm/versions/node/v8.11.3/bin/node 2.3. 查看已经安装的版本 1nvm ls v8.11.3-&gt; v10.7.0 // -&gt; 表示当前使用的版本default -&gt; 10 (-&gt; v10.7.0) // `default` 表示默认使用的版本node -&gt; stable (-&gt; v10.7.0) (default)stable -&gt; 10.7 (-&gt; v10.7.0) (default)iojs -&gt; N/A (default)lts/* -&gt; lts/carbon (-&gt; v8.11.3)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.14.3 (-&gt; N/A)lts/carbon -&gt; v8.11.3 2.4. 查看远程服务器上的可用版本 12345// 所有可用版本nvm ls-remote// 只列出稳定（LTS）版本nvm ls-remote --lts 2.5. 切换版本 12345678// 切换到 v8.11.3nvm use 8// 切换到 v10.7.0nvm use 10// 切换到稳定版（LTS）nvm use --lts 2.6. 以指定版本临时运行 12345678// 临时使用 v8.11.3 运行nvm run 8 -vnvm run 8 app.js// 临时使用 v8.11.3 运行，并使用 v8.11.3 的路径nvm exec 8 node -vnvm exec 8 node app.jsnvm exec 8 npm install -g lodash 2.7. 别名 如果安装的版本过多为了方便记住，可以使用别名代替每次输入版本号。 default 别名指向默认的版本。 12345678// nvm alias &lt;name&gt; &lt;version&gt;nvm alias default 8nvm alias n8 8nvm alias n10 10// nvm unalias &lt;name&gt;nvm unalias n8nvm unalias n10 3. 项目 .nvmrc 可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。 之后在项目目录中执行 nvm use, nvm install, nvm exec, nvm run, nvm which 即可。 .nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。 123echo \"8\" &gt; .nvmrcecho \"lts/*\" &gt; .nvmrcecho \"node\" &gt; .nvmrc 4. 常见问题 4.1. 使用 nvm 后加载不到全局包 有时候明明全局安装一个包，但是项目里就是引用不到，是因为 NODE_PATH 环境变量没有设置。修改 ~/.bash_profile 如下： 123// npm root -g 返回当前版本下 npm 包的路径// ~/.nvm/versions/node/v8.11.3/lib/node_modulesexport NODE_PATH=`npm root -g` 5. 参考链接 · Node Version Manager","link":"/2015/12/05/nvm/"},{"title":"查看 Linux 内核版本和发行版信息","text":"Linux 有众多发行版，在编辑通用脚本等工作时通常需要检测： 内核版本 Kernel Version 发行版信息 Distribution Information ... 来兼容它们。这里先挖个坑汇总一些基本命令和检测脚本，方便以后使用。 1. 内核版本 Kernel Version 12345uname -a// Linux localhost.localdomain 3.10.0-862.el7.x86_64 #1 SMP Fri Apr 20 16:44:24 UTC 2018 x86_64 x86_64 x86_64 GNU/Linuxuname -r// 3.10.0-862.el7.x86_64 2. 发行版信息 Distribution Information 发行版信息查看命令和具体的发行版本有关，可以通过如下方式依次判断： 2.1. /etc/*-release 文件 CentOS7 为例 12345678910111213141516171819202122232425ls /etc/ | grep 'release$'// centos-release// os-release// redhat-release// system-releasecat /etc/centos-release// CentOS Linux release 7.5.1804 (Core)cat /etc/os-release// NAME=\"CentOS Linux\"// VERSION=\"7 (Core)\"// ID=\"centos\"// ID_LIKE=\"rhel fedora\"// VERSION_ID=\"7\"// PRETTY_NAME=\"CentOS Linux 7 (Core)\"// ANSI_COLOR=\"0;31\"// CPE_NAME=\"cpe:/o:centos:centos:7\"// HOME_URL=\"https://www.centos.org/\"// BUG_REPORT_URL=\"https://bugs.centos.org/\"// // CENTOS_MANTISBT_PROJECT=\"CentOS-7\"// CENTOS_MANTISBT_PROJECT_VERSION=\"7\"// REDHAT_SUPPORT_PRODUCT=\"centos\"// REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" 2.2. lsb_release 命令 部分系统默认没有安装 lsb_release，要手动安装 1234567yum install -y redhat-lsblsb_release -a// LSB Version: :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarch// Distributor ID: CentOS// Description: CentOS Linux release 7.5.1804 (Core)// Release: 7.5.1804// Codename: Core 2.3. /proc/version 文件 12cat /proc/version// Linux version 3.10.0-862.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) ) #1 SMP Fri Apr 20 16:44:24 UTC 2018 2.4. hostnamectl 命令 部分发行版使用了 Systemd，可以 hostnamectl 命令查看查看当前主机的信息 123456789101112hostnamectl// Static hostname: localhost.localdomain// Icon name: computer-vm// Chassis: vm// Machine ID: 085c99725433460e9b2a00df4c364940// Boot ID: f6c3ff7f068d41b0b1aaded0a87bf70e// Virtualization: vmware// Operating System: CentOS Linux 7 (Core)// CPE OS Name: cpe:/o:centos:centos:7// Kernel: Linux 3.10.0-862.el7.x86_64// Architecture: x86-64 3. 检测脚本 3.1. sh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/bin/sh# Detects which OS and if it is Linux then it will detect which Linux Distribution.OS=`uname -s`REV=`uname -r`MACH=`uname -m`GetVersionFromFile()&#123; VERSION=`cat $1 | tr \"\\n\" ' ' | sed s/.*VERSION.*=\\ // `&#125;if [ \"$&#123;OS&#125;\" = \"SunOS\" ] ; then OS=Solaris ARCH=`uname -p` OSSTR=\"$&#123;OS&#125; $&#123;REV&#125;($&#123;ARCH&#125; `uname -v`)\"elif [ \"$&#123;OS&#125;\" = \"AIX\" ] ; then OSSTR=\"$&#123;OS&#125; `oslevel` (`oslevel -r`)\"elif [ \"$&#123;OS&#125;\" = \"Linux\" ] ; then KERNEL=`uname -r` if [ -f /etc/redhat-release ] ; then DIST='RedHat' PSUEDONAME=`cat /etc/redhat-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/redhat-release | sed s/.*release\\ // | sed s/\\ .*//` elif [ -f /etc/SUSE-release ] ; then DIST=`cat /etc/SUSE-release | tr \"\\n\" ' '| sed s/VERSION.*//` REV=`cat /etc/SUSE-release | tr \"\\n\" ' ' | sed s/.*=\\ //` elif [ -f /etc/mandrake-release ] ; then DIST='Mandrake' PSUEDONAME=`cat /etc/mandrake-release | sed s/.*\\(// | sed s/\\)//` REV=`cat /etc/mandrake-release | sed s/.*release\\ // | sed s/\\ .*//` elif [ -f /etc/debian_version ] ; then DIST=\"Debian `cat /etc/debian_version`\" REV=\"\" fi if [ -f /etc/UnitedLinux-release ] ; then DIST=\"$&#123;DIST&#125;[`cat /etc/UnitedLinux-release | tr \"\\n\" ' ' | sed s/VERSION.*//`]\" fi OSSTR=\"$&#123;OS&#125; $&#123;DIST&#125; $&#123;REV&#125;($&#123;PSUEDONAME&#125; $&#123;KERNEL&#125; $&#123;MACH&#125;)\"fiecho $&#123;OSSTR&#125; 3.2. python 12345678910111213// python3cd ~wget https://raw.githubusercontent.com/python/cpython/master/Lib/platform.pychmod +x platform.py./platform.py// Linux-4.9.87-linuxkit-aufs-x86_64-with-centos-7.5.1804-Core// python2cd ~wget https://raw.githubusercontent.com/python/cpython/2.7/Lib/platform.pychmod +x platform.py./platform.py// Linux-3.10.0-862.el7.x86_64-x86_64-with-centos-7.5.1804-Core 4. 参考链接 · Detecting Underlying Linux Distro","link":"/2016/02/20/linux-version/"},{"title":"Mac 修饰键和热键","text":"MacOS 键盘按键修饰符: GLYPH HTML Entity NAME ⌘ &amp;#8984; Command ⌥ &amp;#8997; Option ⇧ &amp;#8679; Shift ⌃ &amp;#8963; Control ⎋ &amp;#9099; Esc ⇪ &amp;#8682; Caps lock ⏏ &amp;#9167; Eject ↵ &amp;#8629; &amp;crarr; Return ⌫ &amp;#9003; Delete ⌦ &amp;#8998; Forward Delete → &amp;#8594; &amp;rarr; Right ← &amp;#8592; &amp;larr; Left ↑ &amp;#8593; &amp;uarr; Up ↓ &amp;#8595; &amp;darr; Down ⇞ &amp;#8670; Page Up ⇟ &amp;#8671; Page Down ↖ &amp;#8598; Home ↘ &amp;#8600; End ⌧ &amp;#8999; Clear ⇥ &amp;#8677; Tab ⇤ &amp;#8676; Shift Tab ␣ &amp;#9251; Space MacOS 常用的快捷键: 系统： ⌘ + tab 切换应用程序 ⌘ + ⌫ 将选中的文件移动到废纸篓 ⌘ + c 拷贝 ⌘ + v 粘贴 ⌘ + ⌥ + v 移动文件 ⌘ + q 退出当前应用 ⌘ + h 隐藏当前窗口 ⌘ + m 最小化当前窗口 ⌘ + w 关闭当前窗口 截图： ⌘ + ⇧ + 3 截屏并保存桌面 ⌘ + ⇧ + ⌃ + 3 截屏并保存剪贴板 ⌘ + ⇧ + 4 截区域并保存桌面 ⌘ + ⇧ + ⌃ + 4 截区域并保存剪贴板 文本导航: ⌃ + b 后移光标 ⌃ + f 前移光标 ⌃ + a 跳到行首 ⌃ + e 跳到行尾 ⌃ + u 删除光标前到行首 ⌃ + k 删除光标处到行尾 ⌃ + h 删除光标前的字符 ⌃ + d 删除光标处的字符 ⌃ + w 删除光标前的单词 ⌃ + y 粘贴最后一次的删除 ⎋ + b ⌥ + ← 后一个单词 ⎋ + f ⌥ + → 前一个单词 iTerm: ⌃ + p 前一条命令 ⌃ + n 后一条命令 ⌃ + r 查找相关历史命令 ⌘ + k 清屏 ⌘ + t 新建标签 ⌘ + n 新建窗口 ⌘ + → ⌘ + ← 切换标签 ⌘ + ⇧ + [ ⌘ + ⇧ + ] 切换标签 ⌘ + ⇧ + → ⌘ + ⇧ + ← 移动标签 ⌘ + d 新建垂直分隔面板 ⌘ + ⇧ + d 新建水平分隔面板 ⌘ + ⌥ + → ⌘ + ⌥ + ← ⌘ + ⌥ + ↑ ⌘ + ⌥ + ↓ 切换面板 ⌘ + ] 切换到下一个面板 ⌘ + [ 切换到上一个面板 ⌘ + ⌃ + → ⌘ + ⌃ + ← ⌘ + ⌃ + ↑ ⌘ + ⌃ + ↓ 调整面板 MacOS 快捷键设置： &nbsp; 使用 CheatSheet 查看当前软件的快捷键: &nbsp; 参考链接 · Mac keyboard shortcuts · CheatSheet","link":"/2016/04/24/mac-keyboard/"},{"title":"Systemd 定时器单元 - Timer","text":"Timers 是以 .timer 为后缀名的 systemd 单元文件，用于控制 .service 文件或事件。Timers 可用来代替 cron。Timers 内置了日历定时事件和单调定时事件的支持，并可以异步执行这些事件。 更多关于 Systemd 的说明参见 这篇文章。 1. 定时器单元 Timers 是以 .timer 为后缀的 systemd 单元文件。Timers 和其他单元配置文件是类似的，它通过相同的路径加载，不同的是包含了 [Timer] 部分。 [Timer] 部分定义了何时以及如何激活定时事件。Timers 可以被定义成以下两种类型： 1.1. 单调定时器 即从一个时间点过一段时间后激活定时任务。所有的单调计时器都遵循如下形式： OnTypeSec=。 OnBootSec 和 OnActiveSec 是常用的单调定时器。 1.2. 实时定时器 （类似于 cronjobs ） 通过日历事件激活定时任务。 使用 OnCalender= 来定义实时定时器。 要查阅完整的定时器选项参见 Timer unit configuration。 关于日历事件和时间段的定义参见 Time and date specifications. 2. 服务单元 每个 .timer 文件所在目录都得有一个对应的 .service 文件（如 foo.timer 和 foo.service）。.timer 用于激活并控制 .service 文件。 .service 文件中不需要包含 [Install] 部分，因为这由 timer 单元接管。必要时通过在定时器的 [Timer] 部分指定 Unit= 选项来控制一个与定时器不同名的服务单元。 更多服务单元说明参见 这篇文章。 3. 管理 使用 timer 单元时像其他单元一样 enable 或 start 即可（别忘了添加 .timer 后缀）。 3.1. 查看单元文件 1234567891011# 查看所有单元systemctl list-unit-files# 查看所有 Service 单元systemctl list-unit-files --type=service# 查看所有 Timer 单元systemctl list-unit-files --type=timer# 查看所有正在运行的定时器systemctl list-timers 3.2. 单元管理命令 1234567891011121314151617181920# 启动单元systemctl start foo.timer# 关闭单元systemctl stop foo.timer# 重启单元systemctl restart foo.timer# 杀死单元进程systemctl kill foo.timer# 查看单元状态systemctl status foo.timer# 开机自动执行该单元systemctl enable foo.timer# 关闭开机自动执行systemctl disable foo.timer 3.3. 日志相关命令 1234567891011121314# 查看整个日志journalctl# 查看 foo.timer 的日志journalctl -u foo.timer# 查看 foo.timer 和 foo.service 的日志journalctl -u foo# 从结尾开始查看最新日志journalctl -f# 从结尾开始查看 foo.timer 的日志journalctl -f -u foo.timer 4. 配置示例 4.1. 单调定时器 定义一个在系统启动 15 分钟后执行，且之后每周都执行一次的定时器。 /etc/systemd/system/foo.timer123456789[Unit]Description=Run foo weekly and on boot[Timer]OnBootSec=15minOnUnitActiveSec=1w [Install]WantedBy=timers.target 4.2. 实时定时器 定义一个每周执行一次（明确时间为周一上午十二点）且上次未执行就立即执行的定时器。 /etc/systemd/system/foo.timer123456789[Unit]Description=Run foo weekly[Timer]OnCalendar=weeklyPersistent=true [Install]WantedBy=timers.target 4.3. 定时器单元文件说明 OnActiveSec：定时器生效后，多少时间开始执行任务OnBootSec：系统启动后，多少时间开始执行任务OnStartupSec：Systemd 进程启动后，多少时间开始执行任务OnUnitActiveSec：该单元上次执行后，等多少时间再次执行OnUnitInactiveSec： 定时器上次关闭后多少时间，再次执行OnCalendar：基于绝对时间，而不是相对时间执行AccuracySec：如果因为各种原因，任务必须推迟执行，推迟的最大秒数，默认是60秒Unit：真正要执行的任务，默认是同名的带有.service后缀的单元Persistent：如果设置了该字段，即使定时器到时没有启动，也会自动执行相应的单元WakeSystem：如果系统休眠，是否自动唤醒系统 5. 案例一：定时追加文本 5.1 创建脚本 123cd /roottouch backup_www.shchmod +x backup_www.sh backup_www.sh123456789#!/bin/bash# 向 /root/backup_www.txt 文件中追加当前时间mydate()&#123; date \"+%Y-%m-%d %H:%M:%S\"&#125;backupdate=$(mydate)echo $&#123;backupdate&#125; &gt;&gt; /root/backup_www.txt 5.2. 创建服务单元 /etc/systemd/system/backup_www.service1234567891011[Unit]Description=www backup service[Service]User=wwwGroup=wwwType=simpleExecStart=/root/backup_www.sh[Install]WantedBy=multi-user.target 5.2. 定时器单元 /etc/systemd/system/backup_www.timer1234567891011[Unit]Description=www backup timer[Timer]# 表示每 15 分钟执行一次OnCalendar=*:0/15Persistent=trueUnit=backup_www.service[Install]WantedBy=multi-user.target 5.3. 创建链接并启动 123456789101112systemctl enable backup_www.servicesystemctl enable backup_www.timersystemctl start backup_www.timersystemctl status backup_www.timer● backup_www.timer - www backup timer Loaded: loaded (/etc/systemd/system/backup_www.timer; enabled; vendor preset: disabled) Active: active (running) since Tue 2018-07-24 12:36:10 UTC; 10min agoJul 24 12:36:10 e36d66eda18f systemd[1]: Started www backup timer.Jul 24 12:36:10 e36d66eda18f systemd[1]: Starting www backup timer. 每隔一分钟运行 cat /root/backup_www.txt 查看运行结果: 2016-07-24 12:46:482016-07-24 12:47:482016-07-24 12:48:482016-07-24 12:49:482016-07-24 12:50:482016-07-24 12:51:482016-07-24 12:52:48 6. 参考链接 · Systemd GitHub · Systemd Office Site · Systemd Unit Man · Timer unit configuration · Time and date specifications","link":"/2016/05/20/systemd-timer/"},{"title":"NodeJS 的 Promise 的用法","text":"回调是JavaScript编程中比较令人纠结的写法，主要是用于处理“并列”或者“并行”的操作，然后在回调函数中处理操作结果。这样原生的回调写法就会带来一下的不便。 回调结果状态不便管理 回调方式自由松散，没有规范约束 例如下面的回调的写法： 123456789101112131415161718function func(num, callback) &#123; setTimeout(() =&gt; &#123; try &#123; let result = 1/num; callback(result, null); &#125; catch(err) &#123; callback(null, err); &#125; &#125;, 1000)&#125;func(1, (result, err) =&gt; &#123; if( err ) &#123; console.log(err) &#125; else &#123; console.log(result) &#125; &#125;) 上述代码中，发现如果要处理回调结果 result 和错误 err ，后续的所有就必须在回调函数里面处理，而且回调函数里面还需要自己处理异常判断。 那如果是使用了Promise来处理回调操作，就可以用以下写法处理。 1234567891011121314function func(num, callback) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; let result = 1/num; resolve(result); &#125;, 1000) &#125;)&#125;func(1).then((result) =&gt; &#123; console.log(result)&#125;).catch((err) =&gt; &#123; console.log(err)&#125;) 1. Promise 用法 1new Promise((resolve, reject) =&gt; &#123;...&#125;).then(onResolved, onRejected) 任务状态管理： resolve 成功状态，对应 Promise.resolve reject 失败状态，对应 Promise.reject error 异常状态， 对应 Promise.reject 或 new Promise().catch(onRejected) Thenabled机制提供任务方法链： new Promise().then().then().catch() 1.1. Resolve 处理任务的成功状态 1.1.1. 普通方式 12345678let p = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; let result = 1; resolve(result); &#125;, 1000)&#125;)p.then((result)=&gt;&#123; console.log(result) &#125;) 1.1.2. 快捷方式 1234let p = Promise.resolve(1)p.then((result)=&gt;&#123; console.log(result) &#125;) 1.2. Reject 处理任务的失败状态 1.2.1 普通方式 12345678910111213141516171819202122232425262728293031323334let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let result = 2; reject(result); &#125;, 100)&#125;)// 有两种方式获取失败状态// 第一种，通过then 第二个函数参数处理失败状态p.then((result)=&gt;&#123; console.log('success:',result);&#125;, (result)=&gt;&#123; console.log('fail:',result);&#125;)// \"fail: 2\"// 第二种，或者通过，catch 获取失败状态p.then((result)=&gt;&#123; console.log('success:',result);&#125;).catch((result)=&gt;&#123; console.log('error:',result);&#125;)// \"error: 2\"// 注意：如果两种方式同时使用的话// 只会被第一种方式reject操作失败的结果p.then((result)=&gt;&#123; console.log('success:',result);&#125;, (result)=&gt;&#123; console.log('fail:',result);&#125;).catch((result)=&gt;&#123; console.log('error:',result);&#125;)// \"fail: 2\" 1.2.2 快捷方式 123456let p = Promise.reject(2)p.then(null, result =&gt; console.log('fail:', result))// 或p.then().catch( result =&gt; console.log('error:', result)) 1.3. Catch 从上述 reject 的使用过程中，会发现, catch操作在没有设置 onRejected 处理的时候，会被catch 捕获失败处理。同时catch 也会捕获 onResolved 和 onRejected中出现的错误。 1.3.1. 正常情况下直接捕获reject结果 1234567891011let p = new Promise((resolve, reject) =&gt; &#123; reject(3)&#125;);p.then((result) =&gt; &#123; console.log('success:', result)&#125;).catch((result) =&gt; &#123; console.log('error:', result)&#125;)// \"error: 3\" 1.3.2. 捕获 onResolved 中错误异常 12345678910111213let p = new Promise((resolve) =&gt; &#123; resolve(3)&#125;);p.then((result) =&gt; &#123; throw new Error('custom resolve error!') console.log('success:', result)&#125;).catch((err) =&gt; &#123; console.log('Custom error:', err)&#125;)// \"Custom error: Error: custom resolve error!\" 1.3.3. 捕获 onRejected 中错误异常 1234567891011let p = new Promise((resolve) =&gt; &#123; reject(3)&#125;);p.then(null, (result) =&gt; &#123; throw new Error('custom reject error!') console.log('fail:', result)&#125;).catch((err) =&gt; &#123; console.log('Custom error:', err)&#125;)// \"Custom error: Error: custom reject error!\"","link":"/2016/07/29/nodejs-promise/"},{"title":"Google 高级搜索","text":"双引号 关键词放在双引号中，代表完全匹配搜索，即返回的网页包含双引号中出现的所有的词，顺序也必须完全匹配。 例如：&quot;搜索 图片&quot; 减号 减号代表搜索不包含减号后面的词的网页。减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。 例如：搜索 -引擎 返回包含 搜索 不包含 引擎 的网页 星号 星号 * 通配符代表任何文字。 例如：搜索*擎 中的 * 号代表任何文字。返回包含 搜索引擎，搜索收擎，搜索巨擎 等内容的网页。 inurl inurl:WORD 搜索关键词出现在url中的网页。 例如：inurl:引擎 返回url中包含 引擎 的网页。 inurl:admin.php allinurl allinurl:WORDS 搜索url中包含多个关键词的网页。 例如：allinurl:搜索 引擎 相当于：inurl:搜索 inurl:引擎。 intitle intitle:WORD 返回title中包含关键词的网页。 例如：intitle:用户登录 返回title包含 用户登录 的网页 allintitle allintitle:WORDS 返回title中包含多个关键词的网页。 例如：allintitle:搜索 引擎 相当于：intitle:搜索 intitle:引擎 intext intext:WORD 返回正文中包含关键词的网页。 例如：intext:用户登录 返回正文包含 用户登录 的网页 allintext allintext:WORDS 返回正文中包含多个关键词的网页。 例如：allintext:搜索 引擎 相当于：intext:搜索 intext:引擎 inanchor inanchor:WORD 返回链接锚点中包含关键词的网页 例如：inanchor:搜索 返回链接锚点中包含 搜索 的网页。 allinanchor allinanchor:WORDS 返回链接锚点中包含多个关键词的网页 例如：allinanchor:搜索 引擎 返回链接锚点中包含 搜索 和 引擎 的网页。 link link:URL 返回链接到目标URL的网页 info info:URL 返回目标URL信息 filetype filetype:TYPE WORD 返回包含关键词的特定文件。 例如：filetype:pdf 搜索 返回包含 搜索 关键词的所有 pdf 文件。 site site:URL 返回某个域名下的所有网页。 例如：site:google.com，site:.google.com related related:URL 返回与某个网站有关联的网页。 cache cache:URL 返回某些已经被删除的死链接网页。 index of / 列出文件（需要服务器支持） 例如：index of /mp3","link":"/2016/08/29/google-search/"},{"title":"使用 Pyenv 管理 Python","text":"pyenv 是 Python 的版本管理工具。 它可以改变全局的 Python 版本，安装多个版本的 Python，设置目录级别的 Python 版本，还能创建和管理 virtual python environments。 pyenv 的特别之处在于，它并没有使用将不同的 PATH 植入不同的 shell 这种高耦合的工作方式，而是简单地在 PATH 的最前面插入了一个垫片路径（shims）：$(pyenv root)/shims:/usr/local/bin:/usr/bin:/bin。使得对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而使后方的系统路径失效。 1. 安装 脚本自动安装 1curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 直接从 GitHub 安装 1git clone https://github.com/pyenv/pyenv.git ~/.pyenv 2. 配置 编辑 .bash_profile 文件 ~/.bash_profile123export PATH=\"~/.pyenv/bin:$PATH\"eval \"$(pyenv init -)\"eval \"$(pyenv virtualenv-init -)\" 重新载入 1source ~/.bash_profile 2. 使用 升级 1pyenv update 卸载 12rm -fr ~/.pyenv// 删除 ~/.bash_profile 中之前添加的配置 查看已经安装的版本 1pyenv versions 查看当前使用的版本 1pyenv version 查看可安装的版本 1pyenv install --list 安装指定版本 1pyenv install 3.7.0 卸载指定版本 1pyenv uninstall 3.7.0 设置全局版本，不建议改变全局设置 1pyenv global 3.7.0 设置局部版本，在当前目录下生成 .python-version，对此目录及其子目录下都生效 1pyenv local 3.7.0 取消局部版本 1pyenv local --unset 设置面向 shell 的版本，设置当前 shell 的 PYENV_VERSION 环境变量 1pyenv shell 3.7.0 取消面向 shell 的版本 1pyenv shell --unset 创建垫片路径，为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，每当增删了 python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令 1pyenv rehash 优先级 shell &gt; local &gt; global 3. 虚拟环境 安装 pyenv 后，通过 pyenv-virtualenv 插件可以很好的和 virtualenv 结合 创建虚拟环境，生成到目录 ~/.pyenv/versions/[version]/envs/ 下，然后链接到 ~/.pyenv/versions/ 下 1234// pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt;// 若不指定 python 版本， 默认使用当前环境 python 版本// 更多的选项参见 virtualenv 的使用说明pyenv virtualenv 3.7.0 virtualenv-name 列出所有虚拟环境 1pyenv virtualenvs 激活虚拟环境 1pyenv activate 退出虚拟环境 1pyenv deactivate 删除虚拟环境 1pyenv uninstall virtualenv-name 4. 参考链接 · pyenv · virtualenv","link":"/2016/09/30/pyenv/"},{"title":"MacOS VMware 网络设置","text":"VMware 安装后主机上多了两个 VMnet1 和 VMnet8 虚拟网卡，由它们控制虚拟机与主机间的网络链接方式。 VMware 默认有三种链接方式: VMnet0 桥接网络 虚拟机相当与网络上的一台独立计算机，与主机一样，拥有一个独立的 IP 地址。 VMnet1 仅主机网络 虚拟机只能和主机相互访问，不能访问外部网络。 VMnet8 NAT网络 虚拟机在外部网络上共享主机的 IP 地址，主机为虚拟机发出的网络流量进行网络地址转换。 &nbsp; 1. 主机设置 主机通过 ifconfig 命令可以查看两个网卡的信息： 123456vmnet1: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:01 inet 172.16.233.1 netmask 0xffffff00 broadcast 172.16.233.255vmnet8: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:50:56:c0:00:08 inet 192.168.113.1 netmask 0xffffff00 broadcast 192.168.113.255 Windows 下可以通过界面修改网卡信息，但是 MacOS 下需要直接修改配置文件： /Library/Preferences/VMware\\ Fusion/networking 修改后需要执行 vmnet-cli --configure 再生成下列文件： 注意：直接修改下列文件没用。 /Library/Preferences/VMware\\ Fusion/vmnet1/dhcpd.conf /Library/Preferences/VMware\\ Fusion/vmnet8/dhcpd.conf /Library/Preferences/VMware\\ Fusion/vmnet8/nat.conf 如下修改三种链接方式的 DHCP，网段等信息： /Library/Preferences/VMware Fusion/networking12345678910111213141516VERSION=1,0answer VNET_1_DHCP yesanswer VNET_1_DHCP_CFG_HASH 3B1E88D9119434B209753913AF67F2B032B90DD0answer VNET_1_HOSTONLY_NETMASK 255.255.255.0answer VNET_1_HOSTONLY_SUBNET 172.16.233.0answer VNET_1_VIRTUAL_ADAPTER yesanswer VNET_2_DHCP noanswer VNET_2_NAT noanswer VNET_2_NAT_PARAM_UDP_TIMEOUT 30answer VNET_2_VIRTUAL_ADAPTER noanswer VNET_8_DHCP yesanswer VNET_8_DHCP_CFG_HASH ED961C19E7E96A10AFD637F8C28197AEA50C5C57answer VNET_8_HOSTONLY_NETMASK 255.255.255.0answer VNET_8_HOSTONLY_SUBNET 192.168.113.0answer VNET_8_NAT yesanswer VNET_8_VIRTUAL_ADAPTER yes 上面的设置表示： VMnet8 子网为 192.168.113.0，并开启 DHCP，主机的 IP 默认为 192.168.113.1，网关和 DNS 默认为 192.168.113.2， VMnet0 子网为 172.16.233.0，并开启 DHCP，主机的 IP 默认为 172.16.233.1，DNS 默认为 172.16.233.2， 保存修改后重启 VMware 即可生效，如果不想重启也可以使用 vmnet-cli 命令： 123sudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --configuresudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --stopsudo /Applications/VMware\\ Fusion.app/Contents/Library/vmnet-cli --start 然后再次通过 ifconfig 确认下是否修改成功。 2. 虚拟机设置 以 VMware Fusion 10.1.2 安装 CentOS 7 64 为例， 2.1. VMnet8 NAT网络 虚拟机在外部网络上共享主机的 IP 地址，主机为虚拟机发出的网络流量进行网络地址转换。 &nbsp; 修改虚拟机信息： 12// ens33 为网卡名vi /etc/sysconfig/network-scripts/ifcfg-ens33 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=none # dhcp 表示自动获取 IP，none：使用 IPADDR 设置静态 IPDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33 # 网卡名UUID=28ad865d-5235-4454-9688-a1bce4637664DEVICE=ens33ONBOOT=yes # 开机启动IPADDR=192.168.113.20 # IPPREFIX=24GATEWAY=192.168.113.2 # 网关DNS1=192.168.113.2 # DNSIPV6_PRIVACY=no 建议固定 IP，这样不用每次在主机要链接虚拟机时还要先查看具体 IP。注意使用固定 IP 时要和主机在同一网段。 保存修改后重启网络服务： CentOS 7 使用 Systemd 管理服务，更多关于 Systemd 的用法参见：这篇文章。 1234567// 重启网格systemctl restart network// orservice network restart// 查看是否生效ip addr 最后检查主机，虚拟机，外网间是否能正常通讯： 123456789// 主机ping 192.168.113.20// 虚拟机ping 192.168.113.1ping baidu.com// 主机尝试用 ssh 链接虚拟机ssh root@192.168.113.20 2.2. VMnet0 桥接网络 虚拟机相当与网络上的一台独立计算机，与主机一样，拥有一个独立的IP地址。 &nbsp; 修改虚拟机信息： 注：我的主机 IP 是 192.168.0.10，网关是 192.168.0.1。 12// ens33 为网卡名vi /etc/sysconfig/network-scripts/ifcfg-ens33 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=28ad865d-5235-4454-9688-a1bce4637664DEVICE=ens33ONBOOT=yesIPADDR=192.168.0.20PREFIX=24GATEWAY=192.168.0.1DNS1=192.168.0.1IPV6_PRIVACY=no 保存修改后参见上述 VMnet8 NAT网络 的操作重启并检查。 2.3. VMnet1 仅主机网络 虚拟机只能和主机相互访问，不能访问外部网络。 &nbsp; 修改虚拟机信息： 注：我的主机 IP 是 192.168.0.10，网关是 192.168.0.1。 12// ens33 为网卡名vi /etc/sysconfig/network-scripts/ifcfg-ens33 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=28ad865d-5235-4454-9688-a1bce4637664DEVICE=ens33ONBOOT=yesIPADDR=172.16.233.20PREFIX=24GATEWAY=172.16.233.1DNS1=172.16.233.1IPV6_PRIVACY=no 保存修改后参见上述 VMnet8 NAT网络 的操作重启并检查。 注：此链接方式下只能主机与虚拟机通讯，不能与外网通讯。 3. 参考链接 · VMware Documentation · Modifying the DHCP settings of vmnet1 and vmnet8 in Fusion · Understanding networking types in VMware Fusion · Red Hat Enterprise Linux 7 Document · Red Hat Enterprise Linux 7 Networking Guide","link":"/2016/11/01/mac-vmware-network/"},{"title":"CentOS7 下编译安装 Memcached 1.5 系列","text":"Memcached 是一个高性能的分布式内存对象缓存系统，用于以减轻数据库负载。 1. 结构规划 用户名 memcached用户组 memcached端口 2307# 源码包/root/tmp/memcached-1.5.9.tar.gz# 解压后源码/root/tmp/memcached-1.5.9# 编译目录/root/tmp/build# 编译安装错误/root/tmp/configure.err/root/tmp/make.err/root/tmp/install.err# 安装目录/usr/local/memcached-1.5.9# 工作目录/var/sites/memcached-1.5.9 # 配置文件目录 /etc # Systemd Unit File /systemd 2. 下载源码包 到 官网下载 最新版。目前最新版本是 memcached-1.5.9.tar.gz。 12cd /root/tmp/wget -O ./memcached-1.5.9.tar.gz http://www.memcached.org/files/memcached-1.5.9.tar.gz 3. 安装依赖 123for packages in libevent libevent-devel; do yum -y install $packages;done; 4. 添加用户和组 12groupadd memcached;useradd -s /sbin/nologin -d /dev/null -M -g memcached memcached; 5. 添加端口 添加运程访问端口 2307，Memcached 默认使用 11211 12firewall-cmd --permanent --zone=public --add-port=2307/tcp;firewall-cmd --reload; 6. 解包并编译 1234567891011121314cd /root/tmp/tar -zxvf memcached-1.5.9.tar.gz -C ./cd memcached-1.5.9./configure --help &gt; ../option# 编译并导出错误到 ../configure.err./configure --prefix=/usr/local/memcached-1.5.9 2&gt; ../configure.errmake -j 4 2&gt; ../make.errmake -j 4 install 2&gt; ../install.err 7. 配置文件 memcached 编译安装后源码目录下 scripts/memcached.sysconfig 到 /var/sites/memcached-1.5.9/etc/memcached，关修改相应参数。 1234mkdir -p /var/sites/memcached-1.5.9/etc/cd /root/tmp/memcached-1.5.9cp scripts/memcached.sysconfig /var/sites/memcached-1.5.9/etc/memcached memcached1234567cat /var/sites/memcached-1.5.9/etc/memcached | sed -e \"s/#.*//g\" | awk '&#123;if (length !=0) print $0&#125;'USER=\"memcached\"MAXCONN=\"1024\"CACHESIZE=\"64\"OPTIONS=\"\"PORT=\"2307\" 8. Systemd Unit File 编译安装后需要用 Systemd 来管理 Memcached，默认的 Unit File 在编译目录下分别为 scripts/memcached.service、scripts/memcached@.service。其中 memcached@.service 用来启动多实例服务。分别复制到 /var/sites/memcached-1.5.9/systemd 目录并修改重命名为 memcached-1.5.9.service、memcached-1.5.9@.service，做相应修改后用如下命令启用。 12345mkdir -p /var/sites/memcached-1.5.9/systemd/cd /root/tmp/memcached-1.5.9cp scripts/memcached.service /var/sites/memcached-1.5.9/systemd/memcached-1.5.9.servicecp scripts/memcached@.service /var/sites/memcached-1.5.9/systemd/memcached-1.5.9@.service 1systemctl enable /var/sites/memcached-1.5.9/systemd/memcached-1.5.9.service 注：这里并没有直接复制到默认的 Unit File 目录 /etc/systemd/system 下，而是直接通过 systemctl enable 机制创建相关的链接文件。这样的做的好处是所有的配置文件、启动脚集中在一个目录下方便管理。 memcached-1.5.9.service12345678910111213141516cat /var/sites/memcached-1.5.9/systemd/memcached-1.5.9.service | sed -e \"s/#.*//g\" | awk '&#123;if (length !=0) print $0&#125;'[Unit]Description=memcached daemonAfter=network.target[Service]EnvironmentFile=/var/sites/memcached-1.5.9/etc/memcachedExecStart=/usr/local/memcached-1.5.9/bin/memcached -p $&#123;PORT&#125; -u $&#123;USER&#125; -m $&#123;CACHESIZE&#125; -c $&#123;MAXCONN&#125; $OPTIONSPrivateTmp=trueProtectSystem=fullNoNewPrivileges=truePrivateDevices=trueCapabilityBoundingSet=CAP_SETGID CAP_SETUID CAP_SYS_RESOURCERestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX[Install]WantedBy=multi-user.target 9. 服务管理 12345678# 查看当前状态systemctl status memcached-1.5.9# 启动systemctl start memcached-1.5.9# 停止systemctl stop memcached-1.5.9 10. memcached-tool 源码包内置了一个 perl 写的 scripts/memcached-tool 管理脚本，可以用来查看 Memcached 的运行状态。 注：这个脚本并不会自动安装到安装目录中，因此要使用的话要手动复制过去 12cd /root/tmp/memcached-1.5.9cp scripts/memcached-tool /usr/local/memcached-1.5.9/bin/memcached-tool 123[root@localhost ~]# /usr/local/memcached-1.5.9/bin/memcached-tool 127.0.0.1:2320 # Item_Size Max_age Pages Count Full? Evicted Evict_Time OOM 1 96B 46771s 1 1 no 0 0 0","link":"/2018/08/06/memcached/"},{"title":"查看 SELinux 状态及如何关闭","text":"1. 查看 SELinux 状态： SELinux 有三个状态 Enforcing，Permissive，Disabled，当中 Enforcing 是预设的模式。 123sestatus -v // orgetenforce 2. 关闭 2.1. 临时关闭 setenforce 指令可以即时切换 Enforcing 及 Permissive 这两个模式，但这些改动在系统重新开机时不会被保留。 1setenforce 0 2.2. 永久关闭 直接修改配置文件 /etc/selinux/config 禁用 SELinux。 /etc/selinux/config12#SELINUX=enforcingELINUX=disabled 3. 参考链接 · SELinux","link":"/2018/08/07/selinux/"},{"title":"任务自动管理工具 Grunt","text":"在前端的开发过程中，经常会遇到一些重复性的任务，比如合并文件、压缩代码、检查语法错误、将Less代码转成CSS代码等等。 通常，我们需要使用不同的工具，来完成不同的任务，既重复劳动又非常耗时。Grunt就是为了解决这个问题而发明的工具，可以帮助我们自动管理和运行各种任务。 简单说，Grunt是一个自动任务运行器，会按照预先设定的顺序自动运行一系列的任务。 这可以简化工作流程，减轻重复性工作带来的负担。 1. 安装 Grunt基于NodeJS，安装之前先确保系统已经安装好NodeJS。 运行下面的命令全局安装Grunt命令行grunt-cli 1npm install -g grunt-cli 注意，安装grunt-cli并不等于安装了Grunt！Grunt CLI的任务很简单：调用与Gruntfile在同一目录中 Grunt。这样带来的好处是，允许你在同一个系统上同时安装多个版本的 Grunt。 2. 初始化 新建一个测试项目 grunt-learn-01，并初始化 12345cd ~/gruntmkdir grunt-learn-01cd grunt-learn-01touch GruntFile.jsnpm init npm init 命令使用交互方式生成 package.json 文件，当然你也可以手动创建。 .├── GruntFile.js└── package.json 通过 npm install 安装Grunt和项目所需的Grunt插件， 注意插件名格式一般都 grunt-contrib-xxx 12345npm install --save grunt # 默认安装最新版本npm install --save grunt-contrib-less # less编译成cssnpm install --save grunt-contrib-uglify # js压缩npm install --save grunt-contrib-concat # 文件合并npm install --save grunt-contrib-watch # 文件监视 3. 配置任务 所有的任务都配置在 package.json 文件在同一目录下的 GruntFile.js 文件中。 GruntFile.js 文件格式如下： 123456789101112131415161718192021222324252627module.exports = function(grunt) &#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), // less 任务（task） less: &#123; // foo 目标（target） foo: &#123; // 任务主体 &#125;, bar: &#123;&#125;, &#125;, uglify: &#123; foo: &#123;&#125; &#125;, concat: &#123;&#125;, watch: &#123;&#125;, &#125;); // 插件列表 grunt.loadNpmTasks('grunt-contrib-less'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-watch'); // 注册任务 grunt.registerTask('default', ['less', 'uglify', 'concat', 'watch']);&#125;; 在上面的案例中，less 任务有名为 foo 和 bar 两个目标，而 uglify 任务仅仅只有一个名为 foo 目标。 grunt less:foo 将执行 less 任务（task）下的 foo 目标（target） grunt less 将执行 less 任务（task）下的所有目标（target） 任务主体有如下四种定义方式： 简洁格式 文件对象格式 文件数组格式动 态构建文件对象格式 3.1. 简洁格式 这种形式允许每个目标对应一个 src-dest 文件映射。 12345678910grunt.initConfig(&#123; less: &#123; // 编译 src/css/ 目录下的 aaa.less 和 bbb.less // 生成到 dest/css/ 目录下 ccc.css foo: &#123; src: ['src/css/aaa.less', 'src/css/bbb.less'], dest: 'dest/css/ccc.css', &#125;, &#125;,&#125;); 3.2. 文件对象格式 这种形式支持每个目标对应多个 src-dest 形式的文件映射， 属性名就是目标文件，源文件就是它的值(源文件列表则使用数组格式声明) 123456789grunt.initConfig(&#123; less: &#123; foo: &#123; files: &#123; 'dest/css/ccc.css': ['src/css/aaa.less', 'src/css/bbb.less'], &#125;, &#125;, &#125;,&#125;); 3.3. 文件数组格式动 这种形式支持每个目标对应多个 src-dest 文件映射，同时允许每个映射拥有额外属性： 123456789101112grunt.initConfig(&#123; less: &#123; foo: &#123; files: [ &#123; src: ['src/css/aaa.less', 'src/css/bbb.less'], dest: 'dest/css/ccc.css', &#125;, ], &#125;, &#125;,&#125;); 3.4. 动态构建文件对象格式 当你希望处理大量的单个文件时，这里有一些附加的属性可以用来动态的构建一个文件列表。 1234567891011121314151617grunt.initConfig(&#123; less: &#123; dynamic_mappings: &#123; files: [ // 匹配 src/css/ 目录及其子目录下的所有后缀为 .less 的文件 // 分别编译生成到 dist/css 目录下，保留目录结构并以 .min.css 为后缀 &#123; expand: true, cwd: 'src/', src: ['css/**/*.less'], dest: 'dist/', ext: '.min.css', &#125;, ], &#125;, &#125;,&#125;); 4. 注册任务 通常多个任务是要依次执行，如： 首先 编译 less然后 压缩 js然后 合并多个文件然后 监听上述文件... 我们可以把相关的任务按自己的业务逻辑进行组织，方便执行。 每当运行Grunt时, 你可以为其指定一个或多个任务, 这些任务用于告诉Grunt你想要它做什么事情。 注册任务有如下两种方式： 别名任务 自定义任务 4.1. 别名任务 别名任务，方便将多个相关任务用一个别名来调用。 12// taskList 是一个数组grunt.registerTask(taskName, [description, ] taskList) 下面的案例中，运行 grunt 时没有指定任何任务，default 别名意指默认。 它将自动依次执行 less、uglify、concat 任务。 1grunt.registerTask('default', ['less', 'uglify', 'concat']); taskList 中也可以以 task:target 形式，指定基本的目标。 下面的案例中，运行 grunt dev 时指定了 dev 别名， 它将自动依次执行 less:dev、uglify:dev 和 concat:dev 任务 1grunt.registerTask('dev', ['less:dev', 'uglify:dev', 'concat:dev']); 4.2. 自定义任务 自定义任务执行时，Grunt并不会检查配置和环境，它仅仅执行指定的任务函数，并传递任何使用冒号分割的参数作为函数的参数。 在任务函数里可以调用 Grunt API 执行其它任务，异步执行，自身名称和参数，获取配置... 1grunt.registerTask(taskName, [description, ] taskFunction) 123grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; grunt.log.writeln('Currently running the \"foo\" task.');&#125;); 在一个任务内部，你可以执行其他的任务。 12345678grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; grunt.task.run('bar', 'baz'); // or grunt.task.run(['bar', 'baz']);&#125;);// 等同于grunt.registerTask('foo', 'My \"foo\" task.', ['bar', 'baz']); 任务也可以是异步的。 12345678910111213grunt.registerTask('asyncfoo', 'My \"asyncfoo\" task.', function() &#123; // 进入异步模式并返回 handle 句柄 var done = this.async(); // 异步操作 grunt.log.writeln('Processing task...'); setTimeout(function() &#123; grunt.log.writeln('All done!'); // 异步操作完后执行 handle 句柄 done(); &#125;, 1000);&#125;); 任务也可以访问它们自身名称和参数。 1234567891011grunt.registerTask('foo', 'My \"foo\" task.', function(a, b) &#123; grunt.log.writeln(this.name, a, b);&#125;);// 用法：// grunt foo// logs: \"foo\", undefined, undefined// grunt foo:bar// logs: \"foo\", \"bar\", undefined// grunt foo:bar:baz// logs: \"foo\", \"bar\", \"baz\" 如果记录到任何错误，那么任务就会失败。 12345678910grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; if (failureOfSomeKind) &#123; grunt.log.error('This is an error message.'); &#125; // 如果这个任务出现错误则返回 false if (ifErrors) &#123; return false; &#125; grunt.log.writeln('This is the success message');&#125;); 当任务失败时，所有后续任务都将终止，除非指定 --force 。 12345678910111213// 非异步任务失败 return falsegrunt.registerTask('foo', 'My \"foo\" task.', function() &#123; return false;&#125;);// 异步任务失败 done(false)grunt.registerTask('bar', 'My \"bar\" task.', function() &#123; var done = this.async(); setTimeout(function() &#123; done(false); &#125;, 1000);&#125;); 任务还可以依赖于其他任务的成功执行过。 注意 grunt.task.requires 并不会真正的运行其他任务，它仅仅检查其它任务是否已经执行过，并且没有失败。 1234567891011121314151617grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; return false;&#125;);grunt.registerTask('bar', 'My \"bar\" task.', function() &#123; // 如果 \"foo\" 任务运行失败或者没有运行则任务失败。 grunt.task.requires('foo'); // 如果 \"foo\" 任务运行成功则执行这里的代码。 grunt.log.writeln('Hello, world.');&#125;);// 用法：// grunt foo bar// 没有输出，因为\"foo\"失败。// grunt bar// 没有输出，因为\"foo\"从未运行。 如果任务需要的配置属性不存在，其也可能失败。 123456789grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; // 检查是否存在 meta.name 配置项 grunt.config.requires('meta.name'); // or grunt.config.requires(['meta', 'name']); grunt.log.writeln('This will only log if meta.name is defined in the config.');&#125;); 任务还可以访问配置属性。 12345grunt.registerTask('foo', 'My \"foo\" task.', function() &#123; grunt.log.writeln('The meta.name property is: ' + grunt.config('meta.name')); // or grunt.log.writeln('The meta.name property is: ' + grunt.config(['meta', 'name']));&#125;); 5. 参考链接 · The JavaScript Task Runner","link":"/2015/07/21/grunt/"},{"title":"文件同步工具 - Rsync","text":"1. rsync 简介 rsync（remote synchronize）是 Liunx/Unix 下的一个远程数据同步工具。它可通过 LAN/WAN 快速同步多台主机间的文件和目录，并适当利用 rsync 算法（差分编码）以减少数据的传输。 rsync 算法并不是每一次都整份传输，而是只传输两个文件的不同部分，因此其传输速度相当快。 除此之外，rsync 可拷贝、显示目录属性，以及拷贝文件，并可选择性的压缩以及递归拷贝。 rsync 的目的是实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步。 2. 安装 无论是服务器端还是客户端都是同一个软件包。 Linux 下安装首先从rsync 官网下载对应的安装包。也可以使用 wget 进行下载，如下： 1wget https://download.samba.org/pub/rsync/rsync-3.1.3.tar.gz 安装包下载完毕后，我们开始解压并安装。如下： 1234tar -zxvf rsync-3.1.3.tar.gzcd rsync-3.1.3./configuremake &amp;&amp; make install 使用 systemd 管理 rsync daemon 1234567891011121314cp ./packaging/systemd/rsync.service /usr/lib/systemd/system/// 修改 rsync.service 如下：// [Unit]// Description=fast remote file copy program daemon// ConditionPathExists=/etc/rsyncd.conf// // [Service]// ExecStart=/usr/local/rsync-3.1.3/bin/rsync --daemon --no-detach// // [Install]// WantedBy=multi-user.targetsystemctl enable rsync rsync 源码安装会把 rsync 默认安装到 /usr/local/ 目录下，可以通过如下命令查看全部编辑选项： 1./configure –help 3. rsync 命令参数 rsync安装完毕后，我们来查看下 rsync 命令的帮助，如下： 1rsync –help 常用参数: 123456789-v, --verbose 详细模式输出-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性不变-z, --compress 对备份的文件在传输时进行压缩处理--exclude 排除不需要传输的文件--exclude-from 从文件中读取排除规则--existing 只更新目标端已存在的文件--ignore-existing 只是更新目标端不存在的文件--remove-source-files 删除 SRC 中已经更新成功的文件--delete：删除 DEST 中存在而在 SRC 中没有的文件 4. rsync 三种工作模式 rsync 的七种基本命令格式如下： 1234567rsync [OPTION]... SRC [SRC]... DESTrsync [OPTION]... SRC [SRC]... [USER@]HOST:DESTrsync [OPTION]... SRC [SRC]... [USER@]HOST::DESTrsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DESTrsync [OPTION]... [USER@]HOST:SRC [DEST]rsync [OPTION]... [USER@]HOST::SRC [DEST]rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 七种基本命令包括三种工作方式： 本地同步模式 远程 shell 模式 rsync daemon 模式 前两者是使用管道进行通信和传输数据的，后者是通过网络套接字进行通信和传输数据的，rsync daemon 模式要求在服务器端必须已经运行好 rsync 且监听在指定端口上。 12345678910111213141516本地同步模式: rsync [OPTION]... SRC [SRC]... DEST远程 shell 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST 拉取: rsync [OPTION]... [USER@]HOST:SRC [DEST]rsync daemon 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST 拉取: rsync [OPTION]... [USER@]HOST::SRC [DEST] rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 第一个路径参数一定是源文件路径，即作为同步基准的一方，可以同时指定多个源文件路径。最后一个路径参数则是目标文件路径，也就是待同步方。 路径的格式可以是本地路径，也可以是使用 user@host:path 或 user@host::path 的远程路径，如果主机和 path 路径之间使用单个冒号隔开，表示使用的是远程 shell 模式，而使用双冒号隔开的则表示的是连接rsync daemon 模式。另外，使用 rsync daemon 模式时，还提供了URL格式的路径表述方式 rsync://user@host/path。 如果仅有一个 SRC 或 DEST 参数，则将以类似于 ls -l 的方式列出源文件列表而不是同步文件。 另外一定要注意的一点是，源路径如果是一个目录的话，带上尾随斜线和不带尾随斜线是不一样的，不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身。例如： 12rsync -a /src /destrsync -a /src/ /dest 第一个命令会在 /dest 目录下创建 src 目录，而第二个命令不会在 /dest 目录下创建 src 目录，源路径 /src/ 中的所有文件都直接放在 /dest 目录下。 5. 本地同步模式 此模式的命令如下： 12本地同步模式: rsync [OPTION]... SRC [SRC]... DEST 1rsync -avz /src /dest 6. 远程 shell 模式 此模式的命令如下： 12345远程 shell 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST 拉取: rsync [OPTION]... [USER@]HOST:SRC [DEST] 1234推送: rsync -avz -e \"ssh -p 22\" /src user@192.168.199.247:/dest拉取: rsync -avz -e \"ssh -p 22\" user@192.168.199.247:/src /dest 7. rsync daemon 模式 此模式的命令如下： 1234567rsync daemon 模式: 推送: rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST 拉取: rsync [OPTION]... [USER@]HOST::SRC [DEST] rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST] 连接命令有两种类型： 一种是 rsync 风格使用双冒号的 [USER@]HOST::TARGET，如果想要指定端口号，则需要使用选项 --port。 一种是 url 风格的 rsync://[USER@]HOST[:PORT]/TARGET 上述语法中，其中 TARGET 代表的是模块名，而不是真的文件系统中的路径。 7.1. rsyncd.conf 配置文件 参见官方的配置说明了解全部配置项。 在服务器端启动 rsync daemon 的命令为 rsync --daemon，可能通过 rsync --daemon --help 查看其选项。 服务器端需要两个配置文件：rsyncd.conf 和 rsyncd.secrets。 rsyncd.conf 是 rsync daemon 的主配置文件，rsyncd.secrets 用于存储 rsync 用户名和密码。 MacOS 下默认配置文件为 /usr/local/etc/rsyncd.conf Linux 下默认配置文件为 etc/rsyncd.conf 如果文件不存在，可以手动创建，也可以通过 --config=FILE 选项来指定。 rsyncd.conf 配置实例： 12345678910111213141516171819202122232425262728# 全屏配置port = 873 # rsync 端口，默认873uid = rootgid = rootuser chroot = nomax connections = 200 # 0 表示没有限制timeout = 600 # 0 表示永远等待pid file = /var/run/rsyncd.pidlock file = /var/run/rsyncd.locklog file = /var/run/rsyncd.log# 模块配置[www] # 模块IDpath = /var/www/ # 模块路径uid = www # 模块路径的最终所属用户名gid = www # 模块路径的最终所属用户组ignore errorsread only = no # yes：不能上传，no：能上传write only = no # yes：不能下载，no：能下载list = yes # 客户端请求显示模块列表时，该模块是否显示出来hosts allow = 10.0.0.0/24 # 指定允许连接到该模块的机器，多个用空格隔开hosts deny = 0.0.0.0/32 # 指定不允许连接到该模块的机器auth users = rsync_www # 指定允许链接到该模块的用户名列表，多个用空格隔开secrets file = /etc/rsyncd.secrets # 指定一个包含定义用户名:密码对的文件comment = rsync deamon www module # 模块描述# 其它模块# ... 7.2. rsyncd.secrets 格式 文件的权限一定要是600，否则客户端将不能连接服务器 12user:passworduser1:password1 7.3. 测试 服务端： 123456789useradd -r -s /sbin/nologin wwwmkdir /var/wwwchown -R www:www /var/wwwecho \"rsync_www:123456\" &gt;&gt; /etc/rsyncd.secretschmod 600 /etc/rsyncd.secrets// rsync --deamonsystemctl start rsync 客户端： 1234567891011121314useradd -r -s /sbin/nologin wwwmkdir /var/wwwtouch /var/www/01.txtchown -R www:www /var/wwwecho \"123456\" &gt;&gt; /etc/rsyncd.secretschmod 600 /etc/rsyncd.secretscd /var/www# 列表服务端文件rsync rsync_www@172.17.0.2::www --password-file=/etc/rsyncd.secrets# 上传rsync -avz ./ rsync_www@172.17.0.2::www --password-file=/etc/rsyncd.secrets 8. 参考链接 · rsync · rsyncd.conf man page","link":"/2016/01/04/rsync/"},{"title":"Linux 系统服务管理器 - Systemd","text":"Systemd 是 linux 系统中最新的初始化系统，大多数主流发行版要么已经采用 Systemd，要么即将在下个发布中采用。Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 Systemd 取代了 initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。 查看 CentOS7 下的 /etc/init.d/ 会发现有一个 README 文件。 123456cat /etc/init.d/README// ...// You are running a systemd-based OS where traditional init scripts have// been replaced by native Systemd services files.// ... 1. 单元 Unit Unit 是 Systemd 进行任务管理的基本单位，代表所有系统能够处理的资源，这些资源通过配置文件的方式提供给 Systemd 管理。目前 Unit 有如下类型： .service 系统服务 .socket Sockets .device 系统设备 .mount 挂载点 .automount 自动挂载点 .swap 交换分区 .target 启动目标 .path 文件路径 .timer 定时器 .snapshot Systemd 快照，可以切回某个快照 .slice 进程组 .scope 从 Systemd 外部创建的进程 1.1. Unit 列表 1234567891011121314# 列出正在运行的 Unitsystemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的systemctl list-units --all# 列出所有没有运行的 Unitsystemctl list-units --all --state=inactive# 列出所有加载失败的 Unitsystemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unitsystemctl list-units --type=service 1.2. Unit 的状态 1234567891011121314# 显示系统状态systemctl status# 显示单个 Unit 的状态sysystemctl status rsync.service# 显示 Unit 是否正在运行systemctl is-active rsync.service# 显示 Unit 是否处于启动失败状态systemctl is-failed rsync.service# 显示 Unit 服务是否建立了启动链接systemctl is-enabled rsync.service 1.3. 管理 Unit 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 激活 Utilsystemctl enable rsync.service# 禁止 Utilsystemctl disable rsync.service# 显示单元的手册页（必须由单元文件提供）：systemctl help rsync.service# 立即启动 Unitsystemctl start rsync.service# 立即停止 Unitsystemctl stop rsync.service# 重启 Unitsystemctl restart rsync.service# 杀死 Unit 的所有子进程systemctl kill rsync.service# 重新加载 Unit 的配置文件systemctl reload rsync.service# 重载所有修改过的配置文件systemctl daemon-reload# 显示 Unit 配置文件systemctl cat rsync.service# 编辑 Unit 主配置文件，并重新加载systemctl edit --full rsync.service# 编辑 Unit 子配置文件，并重新加载systemctl edit rsync.service# 显示 Unit 的所有底层参数systemctl show rsync.service# 显示 Unit 的指定属性的值systemctl show -p CPUShares rsync.service# 设置某个 Unit 的指定属性systemctl set-property rsync.service CPUShares=500 2. Unit 的配置文件 每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit。 systemctl show --property=UnitPath 查看按优先级从低到高显示加载目录 默认最先加载 /etc/systemd/system/ 目录下的 Util。 1234# 激活 Utilsystemctl enable rsync.service# 禁止 Utilsystemctl disable rsync.service 2.1. 配置文件的状态 systemctl list-unit-files 命令用于列出所有配置文件。 1234# 列出所有配置文件systemctl list-unit-files# 列出指定类型的配置文件systemctl list-unit-files --type=service 这个列表显示每个配置文件的状态，一共有四种: enabled 已建立启动链接 disabled 没建立启动链接 static 该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖 masked 该配置文件被禁止建立启动链接 2.2. 配置文件的格式 systemctl cat 命令可以查看配置文件的内容。 1234567891011systemctl cat rsync.service[Unit]Description=fast remote file copy program daemonConditionPathExists=/etc/rsyncd.conf[Service]ExecStart=/usr/local/rsync-3.1.3/bin/rsync --daemon --no-detach[Install]WantedBy=multi-user.target 可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。 每个区块内部是一些等号连接的键值对，键值对的等号两侧不能有空格。 以 # 开头的注释可能也能用在 unit-files 中，但是只能在新行中使用。不要在 Systemd 的参数后面使用行末注释，否则 unit 将会启动失败。 1234[Section]Directive1=valueDirective2=value. . . 2.3. 配置文件的区块 [Unit] 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下： Description：简短描述Documentation：文档地址Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行Condition...：当前 Unit 运行必须满足的条件，否则不会运行Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败 [Install] 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下： WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中Alias：当前 Unit 可用于启动的别名Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit [Service] 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下： Type：定义启动时的进程行为。它有以下几种值。 Type=simple：默认值，执行ExecStart指定的命令，启动主进程 Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出 Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行 Type=dbus：当前服务通过D-Bus启动 Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行 Type=idle：若有其他任务执行完毕，当前服务才会运行ExecStart：启动当前服务的命令ExecStartPre：启动当前服务之前执行的命令ExecStartPost：启动当前服务之后执行的命令ExecReload：重启当前服务时执行的命令ExecStop：停止当前服务时执行的命令ExecStopPost：停止当其服务之后执行的命令RestartSec：自动重启当前服务间隔的秒数Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdogTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数Environment：指定环境变量 Unit 配置文件的完整字段清单，请参考官方文档。 2.4. 修改现存单元文件 2.4.1. 直接修改了源配置文件 修改后需要 Systemd 重新加载配置文件，然后重新启动，否则修改不会生效。 12systemctl daemon-reloadsystemctl restart rsync.service 2.4.2. 直接编辑并加载 1systemctl edit --full rsync.service 2.4.3. 添加子配置并加载 如下命令会创建 /etc/systemd/system/rsync.service.d/override.conf 文件用来覆盖 /etc/systemd/system/rsync.service 中的配置。 1systemctl edit rsync.service 3. Target Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。 传统的 init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 12345678910111213141516# 查看当前系统的所有 Targetsystemctl list-unit-files --type=target# 查看一个 Target 包含的所有 Unitsystemctl list-dependencies multi-user.target# 查看启动时的默认 Targetsystemctl get-default# 设置启动时的默认 Targetsystemctl set-default multi-user.target# 切换 Target 时，默认不关闭前一个 Target 启动的进程，# systemctl isolate 命令改变这种行为，# 关闭前一个 Target 里面所有不属于后一个 Target 的进程systemctl isolate multi-user.target Target 与 传统 RunLevel 的对应关系如下。 Traditional runlevel New target name Symbolically linked to...Runlevel 0 | runlevel0.target -&gt; poweroff.targetRunlevel 1 | runlevel1.target -&gt; rescue.targetRunlevel 2 | runlevel2.target -&gt; multi-user.targetRunlevel 3 | runlevel3.target -&gt; multi-user.targetRunlevel 4 | runlevel4.target -&gt; multi-user.targetRunlevel 5 | runlevel5.target -&gt; graphical.targetRunlevel 6 | runlevel6.target -&gt; reboot.target 4.日志管理 Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf。 journalctl 用法如下： # 查看所有日志（默认情况下 ，只保存本次启动的日志）journalctl# 查看内核日志（不显示应用日志）journalctl -k# 查看系统本次启动的日志journalctl -bjournalctl -b -0# 查看上一次启动的日志（需更改设置）journalctl -b -1# 查看指定时间的日志journalctl --since=\"2012-10-30 18:17:16\"journalctl --since \"20 min ago\"journalctl --since yesterdayjournalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"journalctl --since 09:00 --until \"1 hour ago\"# 显示尾部的最新10行日志journalctl -n# 显示尾部指定行数的日志journalctl -n 20# 实时滚动显示最新日志journalctl -f# 查看指定服务的日志journalctl /usr/lib/systemd/systemd# 查看指定进程的日志journalctl _PID=1# 查看某个路径的脚本的日志journalctl /usr/bin/bash# 查看指定用户的日志journalctl _UID=33 --since today# 查看某个 Unit 的日志journalctl -u rsync.servicejournalctl -u rsync.service --since today# 实时滚动显示 Unit 的最新日志journalctl -u rsync.service -f# 合并显示多个 Unit 的日志journalctl -u rsync.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debugjournalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出journalctl --no-pager# 以 JSON 格式（单行）输出journalctl -b -u rsync.service -o json# 以 JSON 格式（多行）输出，可读性更好journalctl -b -u rsync.serviceqq -o json-pretty# 显示日志占据的硬盘空间journalctl --disk-usage# 指定日志文件占据的最大空间journalctl --vacuum-size=1G# 指定日志文件保存多久journalctl --vacuum-time=1years 5. 系统管理命令 5.1. systemctl systemctl 是 Systemd 的主命令，用于管理系统。 1234567891011121314151617181920212223# 命令查看 Systemd 的版本systemctl --version# 重启systemctl reboot# 退出系统并关闭电源systemctl poweroff# CPU停止工作systemctl halt# 待机systemctl suspend# 休眠systemctl hibernate# 休眠并待机systemctl hybrid-sleep# 启动进入救援模式systemctl rescue 5.2. systemd-analyze systemd-analyze 命令用于查看启动耗时。 1234567891011# 查看启动耗时systemd-analyze # 查看每个服务的启动耗时systemd-analyze blame# 显示瀑布状的启动过程流systemd-analyze critical-chain# 显示指定服务的启动流systemd-analyze critical-chain atd.service 5.3. hostnamectl hostnamectl 命令用于查看本地化设置。 12345# 显示当前主机的信息hostnamectl# 设置主机名。hostnamectl set-hostname rhel7 5.4. localectl localectl 命令用于查看本地化设置。 123456# 查看本地化设置localectl# 设置本地化参数。localectl set-locale LANG=en_GB.utf8localectl set-keymap en_GB 5.5. timedatectl timedatectl 命令用于查看当前时区设置。 12345678910# 查看当前时区设置timedatectl# 显示所有可用的时区timedatectl list-timezones # 设置当前时区timedatectl set-timezone America/New_Yorktimedatectl set-time YYYY-MM-DDtimedatectl set-time HH:MM:SS 5.6. loginctl loginctl 命令用于查看当前登录的用户。 12345678# 列出当前sessionloginctl list-sessions# 列出当前登录用户loginctl list-users# 列出显示指定用户的信息loginctl show-user root 6. 参考链接 · Systemd GitHub · Systemd Office Site · Systemd Unit Man · How To Use Systemd · Archlinux Systemd","link":"/2016/03/24/systemd/"},{"title":"使用 Markdown-it 渲染 Hexo","text":"Hexo 默认其官方插件 hexo-renderer-marked 使用 marked 来渲染 Markdown。后来发现这个插件有很多特殊 Markdown 语法不支持。 一番查找后发现 Hexo 官方还有另一个使用 markdown-it 做渲染器的插件 hexo-renderer-markdown-it。该渲染器有众多插件可以用来处理诸如： 缩写 markdown-it-abbr 脚注 markdown-it-footnote &lt;ins&gt; markdown-it-ins 下标 markdown-it-sub 上标 markdown-it-sup 锚点 markdown-it-anchor &lt;dl&gt; markdown-it-deflist &lt;mark&gt; markdown-it-mark 自定义容器 markdown-it-container 表情 markdown-it-emoji HTML 属性 markdown-it-attrs Task Lists markdown-it-task-lists 其它... 1. 安装 进入你的 hexo 的根目录，先删除默认渲染器插件，再安装 hexo-renderer-markdown-it 123456cd myhexoblog/npm uninstall hexo-renderer-marked# npm install --save hexo-renderer-markdown-it# 直接从 GitHub 上安装，支持配置插件npm install --save git+https://github.com/hexojs/hexo-renderer-markdown-it.git 2. 配置 _config.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: # Enable HTML tags in source html: true # Use '/' to close single tags (&lt;br /&gt;). This is only for full CommonMark compatibility. xhtmlOut: true # Convert '\\n' in paragraphs into &lt;br&gt; breaks: true # CSS language prefix for fenced blocks. Can be useful for external highlighters. langPrefix: 'language-' # Autoconvert URL-like text to links linkify: true # Enable some language-neutral replacement + quotes beautification typographer: false # Double + single quotes replacement pairs, when typographer enabled, # and smartquotes on. Could be either a String or an Array. # # For example, you can use '«»„“' for Russian, '„“‚‘' for German, # and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp). quotes: '“”‘’' # Plugins plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-anchor - markdown-it-deflist - markdown-it-mark - markdown-it-container - markdown-it-emoji - markdown-it-attrs - name: markdown-it-task-lists options: enabled: false label: true labelAfter: false # Automatic Headline ID's anchors: # Minimum level for ID creation. (Ex. h2 to h6) level: 2 # A suffix that is prepended to the number given if the ID is repeated. collisionSuffix: 'v' # If `true`, creates an anchor tag with a permalink besides the heading. permalink: false # Class used for the permalink anchor tag. permalinkClass: header-anchor # The symbol used to make the permalink permalinkSymbol: ¶ 3. 安装插件 12345678910111213npm install --save markdown-it-abbrnpm install --save markdown-it-footnotenpm install --save markdown-it-insnpm install --save markdown-it-subnpm install --save markdown-it-supnpm install --save markdown-it-anchornpm install --save markdown-it-deflistnpm install --save markdown-it-marknpm install --save markdown-it-containernpm install --save markdown-it-emojinpm install --save markdown-it-attrsnpm install --save markdown-it-task-lists 4. 示例 至此我们已经安装并配置好新的渲染器，运行如下命令使其生效： 12hexo cleanhexo server -p 4000 4.1. Task List markdown-it-task-lists 用来渲染 GitHub 风格的 Task List。 1234567...- name: markdown-it-task-lists options: enabled: false label: true labelAfter: false... 12345678910###### Task List- [ ] Mercury- [x] Venus- [x] Earth (Orbit/Moon)- [x] Mars- [ ] Jupiter- [ ] Saturn- [ ] Uranus- [ ] Neptune- [ ] Comet Haley Task List Mercury Venus Earth (Orbit/Moon) Mars Jupiter Saturn Uranus Neptune Comet Haley 4.1. 表情 Emoji 4.1.1. EmojiCopy 在 EmojiCopy 中找到你想要的表情，然后点击即可复制粘贴。 😦 😊 😕 4.1.2. Emoji Cheat Sheet 参见 markdown-it-emoji definitions。 1:frowning: :blush: :confused: 4.1.3. 缩写格式（shortcuts） 参见 markdown-it-emoji shortcuts。 1&gt;:( :\") :/ 注：上述三种方式同时可以结合 markdown-it-attrs 插件添加 style 或者 classname 修改表情大小。 1234567891011😦 😊 😕&#123;style=\"font-size:2rem;\"&#125;😦 😊 😕&#123;.h2&#125;:frowning: :blush: :confused:&#123;.h2&#125;&gt;:( :\") :/&#123;.h2&#125; 4.1.4. Twemoji 上述三种方式都是输出 Unicode 字符表情，通过 Twemoji 可以输出图片格式的表情。 实际上 markdown-it-attrs 可以通过 md.renderer.rules.emoji 来设置渲染输出处理机制，默认是直接输出。只需要修改这个地方就能满足要求。 首先需要安装 twemoji 包： 1npm install --save twemoji 然后修改如下代码： node_modules/markdown-it-emoji/index.js1234567891011...var twemoji = require('twemoji') // md.renderer.rules.emoji = emoji_html;md.renderer.rules.emoji = function(token, idx) &#123; return twemoji.parse(token[idx].content, &#123; // options // https://github.com/twitter/twemoji &#125;);&#125;;... Twemoji 可以输出 svg 格式的图片，要修改表情图片的大小，只能在 Css 中修改。 123456.emoji &#123; height: 1.5em; width: 1.5em; margin: 0 .05em 0 .1em; vertical-align: -0.1em;&#125; 5. 参考链接 · hexo-renderer-marked · hexo-renderer-markdown-it · Emoji Cheat Sheet · Github Emojis API · Twemoji · EmojiCopy","link":"/2016/06/25/hexo-render/"},{"title":"Jupyter Notebook","text":"Jupyter Notebook（此前被称为 IPython Notebook）是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。 1. 安装 安装前可以先体验几把 Try Jupyter。 安装 Jupyter Notebook 的前提是需要安装了 Python。 因为使用了 pyenv 来管理 Python，同时安装了 2.7.10 和 3.7.0 两个版本，我们默认使用 3.7.0 来安装。更多关于 pyenv 的用法参见：这篇文章。 12345pyenv shell 3.7.0python --versionpip --versionpip install jupyter 2. 命令行选项 启动并打开浏览器 http://localhost:8888 1jupyter notebook 更多的选项 123Jupyter notebook --help// orJupyter notebook --help-all 3. 配置 查看 Jupyter 相关路径 1jupyter --paths 生成配置文件 ~/.jupyter/jupyter_notebook_config.py 1Jupyter notebook --generate-config ~/.jupyter/jupyter_notebook_config.py12345678# 存放目录c.NotebookApp.notebook_dir = '/jupyter'# 启动后是否自动打开浏览器#c.NotebookApp.open_browser = True# 启动端口#c.NotebookApp.port = 8888 4. 使用 Jupyter 使用单元（Cell）保存各种信息。Cell 有多种类型，有表示代码的 Code 单元，和表示格式化文本的 Markdown 单元。每个代码单元都有一个输出区域，在 Code 单元中输入代码，按 Ctrl + Enter 将运行此代码，代码中最后一个表达式的值将输出区域显示。如果希望屏蔽输出，可以在最后一条语句之后添加一个分号：;。此外，代码中还可以使用 print 语句在输出区域中显示信息。 与 IPython 一样，在 Cell 中可以直接按 Tab 键，可以自动补全。 Markdown 单元主要用来添加说明 Code 单元存放实际的代码块 5. 快捷键 Jupyter 有两种模式的快捷键，编辑模式（Edit mode）和命令模式（Command mode）。编辑模式表示 Cell 处于编辑状态，边框是绿色。命令模式表示 Cell 处于选中状态，边框是灰色。 Esc 编辑模式 -&gt; 命令模式 Enter 命令模式 -&gt; 编辑模式 5.1. 命令模式 F find and replace ↩ enter edit mode ⌘⇧F open the command palette ⌘⇧P open the command palette P open the command palette ⇧↩ run cell, select below ⌃↩ run selected cells ⌥↩ run cell and insert below Y change cell to code M change cell to markdown R change cell to raw 1 change cell to heading 1 2 change cell to heading 2 3 change cell to heading 3 4 change cell to heading 4 5 change cell to heading 5 6 change cell to heading 6 K select cell above ↑ select cell above ↓ select cell below J select cell below ⇧K extend selected cells above ⇧↑ extend selected cells above ⇧↓ extend selected cells below ⇧J extend selected cells below A insert cell above B insert cell below X cut selected cells C copy selected cells ⇧V paste cells above V paste cells below Z undo cell deletion D,D delete selected cells ⇧M merge selected cells, or current cell with cell below if only one cell is selected ⌘S Save and Checkpoint S Save and Checkpoint L toggle line numbers O toggle output of selected cells ⇧O toggle output scrolling of selected cells H show keyboard shortcuts I,I interrupt the kernel 0,0 restart the kernel (with dialog) Esc close the pager Q close the pager ⇧L toggles line numbers in all cells, and persist the setting ⇧␣ scroll notebook up ␣ scroll notebook down 5.2. 编辑模式 ⇥ code completion or indent ⇧⇥ tooltip ⌘] indent ⌘[ dedent ⌘A select all ⌘Z undo ⌘/ comment ⌘D delete whole line ⌘U undo selection Insert toggle overwrite flag ⌘↑ go to cell start ⌘↓ go to cell end ⌥← go one word left ⌥→ go one word right ⌥⌫ delete word before ⌥⌦ delete word after ⌘⇧Z redo ⌘⇧U redo selection ⌃K emacs-style line kill ⌘⌫ delete line left of cursor ⌘⌦ delete line right of cursor ⌃M enter command mode Esc enter command mode ⌘⇧F open the command palette ⌘⇧P open the command palette ⇧↩ run cell, select below ⌃↩ run selected cells ⌥↩ run cell and insert below ⌃⇧Minus split cell at cursor ⌘S Save and Checkpoint ↓ move cursor down ↑ move cursor up 6. 魔法命令（Magics） IPython 提供了许多魔法命令，使得在 IPython 环境中的操作更加得心应手。 魔法命令都以 % 或者 %% 开头，以 % 开头的成为行命令（line magics），%% 开头的称为单元命令（cell magics）。 行命令只对命令所在的行有效，而单元命令则必须出现在单元的第一行，对整个单元的代码进行处理。 %lsmagic 查看所有魔法命令 12345678%lsmagicAvailable line magics:%alias %alias_magic %autocall %automagic %autosave %bookmark %cat %cd %clear %colors %config %connect_info %cp %debug %dhist %dirs %doctest_mode %ed %edit %env %gui %hist %history %killbgscripts %ldir %less %lf %lk %ll %load %load_ext %loadpy %logoff %logon %logstart %logstate %logstop %ls %lsmagic %lx %macro %magic %man %matplotlib %mkdir %more %mv %notebook %page %pastebin %pdb %pdef %pdoc %pfile %pinfo %pinfo2 %popd %pprint %precision %profile %prun %psearch %psource %pushd %pwd %pycat %pylab %qtconsole %quickref %recall %rehashx %reload_ext %rep %rerun %reset %reset_selective %rm %rmdir %run %save %sc %set_env %store %sx %system %tb %time %timeit %unalias %unload_ext %who %who_ls %whos %xdel %xmodeAvailable cell magics:%%! %%HTML %%SVG %%bash %%capture %%debug %%file %%html %%javascript %%js %%latex %%markdown %%perl %%prun %%pypy %%python %%python2 %%python3 %%ruby %%script %%sh %%svg %%sx %%system %%time %%timeit %%writefileAutomagic is ON, % prefix IS NOT needed for line magics. %magic 查看所有魔法命令的文档 1%magic %magic_name? 查看具体魔法命令的文档 12%cd?%bookmark? 6.1. 行命令（line magics） %alias，%unalias 别名 12345678910111213141516171819# 查看所有别名%alias# %l 对应全部参数%alias bracket echo \"Input in brackets: &lt;%l&gt;\"%bracket hello world# Input in brackets: &lt;hello world&gt;# %s 对应空格分开的每个参数%alias parts echo first %s second %s%parts A B# first A second B# 参数不对应则报错%parts A# UsageError: Alias &lt;parts&gt; requires 2 arguments, 1 given.# 删除指定别名%unalias bracket %bookmark 目录标签 1234567891011121314151617# 设置当前目录的标签%bookmark foo # 设置指定目录的标签%bookmark foo ./ # 列出所有标签%bookmark -l # 删除指定标签%bookmark -d foo # 删除所有标签%bookmark -r # 切换到指定标签 %cd -b foo %cd 切换当前工作目录 Jupyter 保存当前会话中所有访问过的目录到变量 _dh 中，可以使用 %dhist 命令查看。 %cd 不同于 !cd 命令，!cd 命令执行后就被丢弃。 12345678# 切换到指定目录%cd &lt;dir&gt;# 切换到指定目录但不输出%cd -q &lt;dir&gt;# 切换到指定标签%cd -b &lt;bookmark_name&gt; %config 配置 IPython 12345678# 查看所有可配置项%config # 查看指定类的所有可配置项%config &lt;class_name&gt; # 修改指定配置项%config IPCompleter.greedy = True %env 查看&amp;修改环境变量 12345678# 查看所有环境变量%env# 查看指定环境变量%env ENV_NAME# 修改指定环境变量%env ENV_NAME=ENV_VALUE %load 载入文件到当前 Cell 可载入本地文件，网络文件，历史，宏。如果要载入的文件大于 200000 个字符会弹出提示，除非使用 -y 选项。 123456789%load myscript.py%load 7-27%load myMacro%load http://www.example.com/myscript.py%load -r 5-10 myscript.py%load -r 10-20,30,40: foo.py%load -s MyClass,wonder_function myscript.py%load -n MyClass%load -n my_module.wonder_function %history 查看输入历史记录 所有的输入历史记录存放到 _i&lt;n&gt; 变量中（_i 指向最后一次输入） 选项： -n 同时打印行号 -o 同时打印输入对应的输出 -f FILENAME 输出结果到文件 打印范围： 默认将打印当前会话的所有历，也可以通过如下格式指定打印范围： 4 当前会话第4行 4-6 当前会话第4至6行 3/1-5 第3个会话的第1至5行 ~2/7 当前会话倒数第2个会话的第7行 ~8/1-~6/5 当前会话倒数第8个会话的第1行至当前会话倒数第6个会话的第5行 1%history -n 4-6 %notebook 导出当前历史到文件 12# 导出当前所有历史到 foo.ipynb%notebook foo.ipynb %pdef 查看可执行对象的定义 12%pdef str.replace# str.replace(self, old, new, count=-1, /) %pdoc 查看对象的文档 1%pdoc str.replace %pinfo，?，%pinfo2，?? 查看帮助文档 123%pinfo str.replace?str.replacestr.replace? %pycat 查看内容 可载入本地文件，网络文件，历史，宏 1234%pycat myscript.py%pycat 7-27%pycat myMacro%pycat http://www.example.com/myscript.py %reset 重置命名空间 1234567891011# -f 表示强制删除，不提示%reset -f# 删除输入历史（In）%reset -f in # 删除输出历史（Out）%reset -f out # 目录历史 (%dhist, _dh)%reset -f dhist %run 运行代码 12%run foo.py%run foo.ipynb %save 保存到文件 12# %save [options] filename n1-n2 n3-n4 … n5 .. n6 …%save output.py 1-10 %store 会话间变量 1234567891011121314151617181920212223# 查看所有变量%store # 删除所有变量%store -z # 存储变量 var%store var # 删除变量 var%store -d var # 加载所有变量%store -r # 加载变量 var%store -r var # 存储变量 var 到文件 var.txt%store var &gt; var.txt # 追加存储变量 var 到文件 var.txt%store var &gt;&gt; var.txt %who， %who_ls，%whos 查看全局变量 12345# 所有全局变量%who # type 为 function 和 str 的全局变量%who function str %sx，!!，%sc，! 运行 Shell 命令并返回结果 12345678910%sx ls -la ./!!ls -la ./%sc ls -la ./!ls -la ./%sx ls_res=ls -la ./ls_res=%sx ls -la ./ls_res=!ls -la ./$sc -l ls_res=ls -la ./ %time 计时 1%time 2**128 6.2. 单元命令（cell magics） %%bash 12345%%bashfor i in 1 2 3 4do echo $idone %%html 12%%html&lt;b style=\"color:red\"&gt;this html block&lt;/b&gt; %%javascript， %%js 12345%%jsvar arr = [1,2,3,4];for(var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i])&#125; %%markdown 12%%markdown__this markdown block__ %%writefile 123456789%%writefile out.py#!/usr/bin/env python# -*- coding: utf-8 -*-def main(): print('Hello World!')if __name__ == '__main__': main() %%capture 12%%capture outputprint('Hello World!') 7. Notebook Server 一般情况下，Jupyter Notebook 服务运行本地通过 http://localhost:8888 访问和使用。 但在某些时候，我们想把 Jupyter Notebook 应用架设在公开的服务器中，以便获取更强的计算能力和更多的内存，同时省去在每台电脑上安装和配置 Jupyter Notebook 的过程。 待续。。。 8. 小技巧 插入图片 IPython.display.Image123456789from IPython.display import display, HTML, Imageimage_url = 'https://www.python.org/static/img/python-logo.png';image_src = '/Users/garryshield/Downloads/python-logo.png';Image(url=image_url)# orImage(filename=image_src)# or display(HTML('&lt;img src=\"'+ image_url +'\"/&gt;')) 待续。。。 9. 参考链接 · Jupyter Notebook · IPython · IPython Documentation · IPython Built-in magic commands","link":"/2016/10/30/jupyter/"},{"title":"CentOS7 下编译安装 MariaDB 10.3 系列","text":"Oracle 买下了 Sun， 考虑到 Oracle 的名声以及其入手之后闭源的可能性，MySQL 之父的 Michael 便先行一步，以他女儿 Maria 的名字开始了 MySQL 的另外一个衍生版本即 MariaDB。主流的 Linux 发行商基本上都开始转而支持使用 MariaDB 以规避 MySQL 不确定性的风险。 1. 结构规划 用户名 mariadb用户组 mariadb端口 2306# 源码包/root/tmp/mariadb-10.3.8.tar.gz# 解压后源码/root/tmp/mariadb-10.3.8 # 编译目录/root/tmp/build# 编译安装错误/root/tmp/configure.err/root/tmp/make.err/root/tmp/install.err# 安装目录/usr/local/mariadb-10.3.8 # 工作目录/var/sites/mariadb-10.3.8 # 数据库、日志目录 /data # 配置文件目录 /etc /my.cnf.d # 其它文件目录，如：sock，pid, lock... /var # Systemd Unit File /systemd 2. 下载源码包 到 官网下载 最新版 MariaDB。目前最新版本是 mariadb-10.3.8.tar.gz。 12cd /root/tmp/wget -O ./mariadb-10.3.8.tar.gz https://downloads.mariadb.org/interstitial/mariadb-10.3.8/source/mariadb-10.3.8.tar.gz 3. 安装依赖 123for packages in openssl openssl-devel cmake ncurses ncurses-devel bison bison-devel jemalloc jemalloc-devel; do yum -y install $packages;done; 4. 安装 devtoolset-7 MariaDB 编译 TokuDB 引擎时会用到 C++11 标准，系统里 GCC 最高版本 4.8.5 是支持 C++11 标准的，可就算指定了 -DCMAKE_CXX_FLAGS=-std=c++11 也不行。手动编译更高版本的 GCC 又太麻烦，这里直接安装了 devtoolset-7，当然你禁用 TokuDB 引擎也无可厚非。 123for packages in centos-release-scl devtoolset-7; do yum -y install $packagesdone; 1234567891011gcc --version// gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-28)// Copyright © 2015 Free Software Foundation, Inc.scl enable devtoolset-7 bash// or. /opt/rh/devtoolset-7/enablegcc --version// gcc (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5)// Copyright (C) 2017 Free Software Foundation, Inc. 5. 添加用户和组 添加用户 mariadb 和组 mariadb 用来启动 MariaBD 服务，MariaDB 默认使用 mysql 用户和 mysql 组。 12groupadd mariadb;useradd -s /sbin/nologin -d /dev/null -M -g mariadb mariadb; 6. 添加端口 添加运程访问端口 2306，MariaDB 默认使用 3306 12firewall-cmd --permanent --zone=public --add-port=2306/tcp;firewall-cmd --reload; 7. 解包并编译 建议新建一个目录用来编译而不是有源码目录里直接编译，这个过程会非常耗时。 123456789101112131415161718192021222324252627282930cd /root/tmp/tar -zxvf mariadb-10.3.8.tar.gz -C ./# 编译目录mkdir buildcd build# 编译并导出错误到 ../configure.errcmake -DCMAKE_INSTALL_PREFIX=/usr/local/mariadb-10.3.8 \\ -DINSTALL_MYSQLDATADIR=/var/sites/mariadb-10.3.8/data \\ -DINSTALL_SYSCONFDIR=/var/sites/mariadb-10.3.8/etc \\ -DINSTALL_SYSCONF2DIR=/var/sites/mariadb-10.3.8/etc/my.cnf.d \\ -DINSTALL_UNIX_ADDRDIR=/var/sites/mariadb-10.3.8/var/mysql.sock \\ -DMYSQL_DATADIR=/var/sites/mariadb-10.3.8/data \\ -DWITH_SYSTEMD=yes \\ -DCONC_WITH_CURL=ON \\ -DCONC_WITH_SSL=ON \\ -DENABLED_LOCAL_INFILE=ON \\ ../mariadb-10.3.8 2&gt; ../configure.err# 查看是否出错cat ../configure.err# 查看所有编译选项cmake -LAH ./make -j 4 2&gt; ../make.errmake -j 4 install 2&gt; ../install.err 8. 配置文件 my.cnf 上面的编译选项 -DINSTALL_SYSCONFDIR，-DINSTALL_SYSCONF2DIR 指定了默认的配置文件位置为 /var/sites/mariadb-10.3.8/etc 和 /var/sites/mariadb-10.3.8/etc/my.cnf.d，安装后 /var/sites/mariadb-10.3.8/etc 的结构如下： 1234567891011121314151617/var/sites/mariadb-10.3.8/etc/├── init.d│ └── mysql├── logrotate.d│ └── mysql├── my.cnf├── my.cnf.d│ ├── client.cnf│ ├── enable_encryption.preset│ ├── mysql-clients.cnf│ └── server.cnf└── systemd └── system └── mariadb.service.d └── tokudb.conf6 directories, 8 files my.cnf1234cat ../sites/mariadb-10.3.8/etc/my.cnf | sed -e \"s/#.*//g\" | awk '&#123;if (length !=0) print $0&#125;'[client-server]!includedir /var/sites/mariadb-10.3.8/etc/my.cnf.d my.cnf.d/client.cnf123456cat /var/sites/mariadb-10.3.8/etc/my.cnf.d/client.cnf | sed -e \"s/#.*//g\" | awk '&#123;if (length !=0) print $0&#125;'[client]port=2306socket=/var/sites/mariadb-10.3.8/var/mysql.sock[client-mariadb] my.cnf.d/server.cnf1234567891011121314151617181920cat /var/sites/mariadb-10.3.8/etc/my.cnf.d/server.cnf | sed -e \"s/#.*//g\" | awk '&#123;if (length !=0) print $0&#125;'[server][mysqld]port=2318socket=/var/sites/mariadb-10.3.8/var/mysql.sockdatadir=/var/sites/mariadb-10.3.8/datacharacter-set-server=utf8log-output=FILElog-basename=logbaselog-error=1general-log=1slow-query-log=1long-query-time=2log-queries-not-using-indexes=1log-bin=1[galera][embedded][mariadb][mariadb-10.3] 9. Systemd Unit File 编译安装后需要用 Systemd 来管理 MariaDB，默认的 Unit File 在编译目录下分别为 support-files/mariadb.service、support-files/mariadb@.service。其中 mariadb@.service 用来启动多实例服务。分别复制到 /var/sites/mariadb-10.3.8/systemd 目录并修改重命名为 mariadb-10.3.8.service、mariadb-10.3.8@.service，做相应修改后用如下命令启用。 12345mkdir -p /var/sites/mariadb-10.3.8/systemd/cd /root/tmp/buildcp support-files/mariadb.service /var/sites/mariadb-10.3.8/systemd/mariadb-10.3.8.servicecp support-files/mariadb@.service /var/sites/mariadb-10.3.8/systemd/mariadb-10.3.8@.service 1systemctl enable /var/sites/mariadb-10.3.8/systemd/mariadb-10.3.8.service 注：这里并没有直接复制到默认的 Unit File 目录 /etc/systemd/system 下，而是直接通过 systemctl enable 机制创建相关的链接文件。这样的做的好处是所有的配置文件、启动脚集中在一个目录下方便管理。 mariadb-10.3.8.service123456789101112131415161718192021222324252627282930313233cat /var/sites/mariadb-10.3.8/systemd/mariadb-10.3.8.service | sed -e \"s/#.*//g\" | awk '&#123;if (length !=0) print $0&#125;'[Unit]Description=MariaDB 10.3.8 database serverDocumentation=man:mysqld(8)Documentation=https://mariadb.com/kb/en/library/systemd/After=network.targetAfter=syslog.target[Install]WantedBy=multi-user.target[Service]Type=notifyPrivateNetwork=falseUser=mariadbGroup=mariadbCapabilityBoundingSet=CAP_IPC_LOCKProtectSystem=fullPrivateDevices=trueProtectHome=truePermissionsStartOnly=trueExecStartPre=/bin/sh -c \"systemctl unset-environment _WSREP_START_POSITION\"ExecStartPre=/bin/sh -c \"[ ! -e /usr/local/mariadb-10.3.8/bin/galera_recovery ] &amp;&amp; VAR= || \\ VAR=`/usr/local/mariadb-10.3.8/bin/galera_recovery`; [ $? -eq 0 ] \\ &amp;&amp; systemctl set-environment _WSREP_START_POSITION=$VAR || exit 1\"ExecStart=/usr/local/mariadb-10.3.8/bin/mysqld $MYSQLD_OPTS $_WSREP_NEW_CLUSTER $_WSREP_START_POSITIONExecStartPost=/bin/sh -c \"systemctl unset-environment _WSREP_START_POSITION\"KillSignal=SIGTERMSendSIGKILL=noRestart=on-abortRestartSec=5sUMask=007PrivateTmp=falseLimitNOFILE=16364 10. 初始化 MariaDB 通过安装目录下的 scripts/mysql_install_db 初始化 MariaDB。 12345mkdir -p /var/sites/mariadb-10.3.8/datachown -R mariadb:mariadb /var/sites/mariadb-10.3.8/datacd /usr/local/mariadb-10.3.8scripts/mysql_install_db --basedir=/usr/local/mariadb-10.3.8 --datadir=/var/sites/mariadb-10.3.8/data --user=mariadb 11. 服务管理 12345678# 查看当前状态systemctl status mariadb-10.3.8# 启动systemctl start mariadb-10.3.8# 停止systemctl stop mariadb-10.3.8 12. 提高安全性 安装目录下的 bin/mysql_secure_installation 用来修改密码、删除匿名用户、取消远程链接。 注：运行此命令要先启动 MariaDB。 12cd /usr/local/mariadb-10.3.8bin/mysql_secure_installation 13. 查看用户表 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost ~]# /usr/local/mariadb-10.3.8/bin/mysql -uroot -pEnter password:Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 16Server version: 10.3.8-MariaDB-log Source distributionCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+4 rows in set (0.018 sec)MariaDB [(none)]&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; select Host,User,Password from user;+-----------+------+-------------------------------------------+| Host | User | Password |+-----------+------+-------------------------------------------+| localhost | root | XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX || 127.0.0.1 | root | XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX || ::1 | root | XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX || % | root | XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX |+-----------+------+-------------------------------------------+4 rows in set (0.003 sec)MariaDB [mysql]&gt; 14. 参考链接 · MariaDB · MariaDB Document · MariaDB Download · devtoolset-7","link":"/2018/08/03/mariadb/"},{"title":"Shell Scripting","text":"Hello World! hello_world.sh12#!/bin/bashecho \"Hello World!\" 1234chmod +x ./hello_world.sh./hello_world.sh# or/bin/bash hello_world.sh 变量 变量名和等号之间不能有空格。 变量名名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 变量名不能使用 bash 里的关键字。 1234567891011121314151617181920var_str1=stringvar_str2='this is a string'var_str3=\"this is another string\"var_str4=\"this is another $&#123;string&#125;\"var_int1=2var_int2=002var_int3='2'var_int4='002'var_float1=3.1425var_float2='3.1425'var_array1=(item0 item1 item2 \"reset item\")var_array2=( item0 item1 item2 \"reset item\") 注释 以&quot;#&quot;开头的行就是注释，会被解释器忽略。 sh里没有多行注释，只能每一行加一个#号。只能像这样： 1234567891011121314#--------------------------------------------# Script Description# author：Garry Shield# site：garryshield.github.io# slogan：stay hungry stay foolish#--------------------------------------------##### Block A Start ######## Block A Description# ###### Block A End ##### 或者 12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF 字符串 字符串可以用单引号，也可以用双引号，也可以不用引号。如果字符串中有空格一定要用双引号。 单引号 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。 1str='this is a string' 双引号 双引号里可以有变量，特殊字符（如：$、`、/）需要使用 / 转义。 12echo '\\\", \\$, \\`, \\\\, `whoami`, $&#123;PWD&#125;' # \\\", \\$, \\`, \\\\, `whoami`, $&#123;PWD&#125;echo \"\\\", \\$, \\`, \\\\, `whoami`, $&#123;PWD&#125;\" # \", $, `, \\, root, /root/shell 字符串长度 1234string=\"www.google.com\"echo $&#123;#string&#125; # 输出 14echo `expr length \"$&#123;string&#125;\"` # 输出 14echo `expr \"$&#123;string&#125;\" : \".*\"` # 输出 14 截取字符串 12345678string=\"www.google.com\"echo $&#123;string:4:6&#125; # 从第4个字符开始截取6个字符，输出 googleecho `expr substr \"$&#123;string&#125;\" 5 6` # 输出 googleecho $&#123;string:4&#125; # 从第4个字符开始截取，输出 google.comecho $&#123;string: -3&#125; # 截取后3个字符 输出 comecho $&#123;string:(-3)&#125; # 同上 indexOf 12string=\"www.google.com\"echo `expr index \"$&#123;string&#125;\" g` # 输出 5 替换 1234567string=\"www.google.com\"echo $&#123;string/g/b&#125; # 代替第一个匹配 输出 www.boogle.comecho $&#123;string//g/b&#125; # 代替所有匹配 输出 www.booble.comecho $&#123;string//google/baidu&#125; # 代替所有匹配 输出 www.baidu.comecho $&#123;string/#www/cloud&#125; # #表示以什么开头来匹配 输出 cloud.google.comecho $&#123;string/%com/com.hk&#125; # %表示以什么结尾来匹配 输出 www.google.com.hk 数组 bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。 数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。 定义数组 在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开。 1array_name=(value0 value1 value2 value3) 或者 123456array_name=( value0 value1 value2 value3) 修改元素 可以不使用连续的下标，而且下标的范围没有限制。 1234array_name[0]=value0array_name[1]=value1array_name[100]=value100array_name[100+1]=value101 获取值 12echo $&#123;array_name[100]&#125;echo $&#123;array_name[100+1]&#125; 获取键 1echo $&#123;!array_name[@]&#125; # 0 1 2 3 100 101 所有值 使用 @ 符号可以获取数组中的所有元素 1echo $&#123;array_name[@]&#125; # value0 value1 value2 value3 value100 value101 获取长度 123456# 取得数组元素的个数echo $&#123;#array_name[@]&#125;echo $&#123;#array_name[*]&#125;# 取得数组单个元素的长度echo $&#123;#array_name[100]&#125; 遍历数组 123for i in $&#123;array_name[@]&#125;; do echo \"value:\" $idone 或者，推荐使用 123for i in \"$&#123;!array_name[@]&#125;\"; do echo \"key:\" $i \"value:\" \"$&#123;array_name[$i]&#125;\"done 或者，慎用此法 123for (( i=0; i&lt;$&#123;#array_name[@]&#125;; i++ )); do echo \"order:\" $i \"value:\" $&#123;array_name[$i]&#125;done indexOf 1234567search=\"value2\"for i in \"$&#123;!array_name[@]&#125;\"; do if [[ \"$&#123;array_name[$i]&#125;\" = \"$&#123;search&#125;\" ]]; then echo \"$&#123;i&#125;\"; fidone# 输出 2 Parameter Expansion 1、Use Default Values ${parameter:-word} 12345#!/bin/shecho -en \"What is your name:\"read mynameecho \"Your name is : $&#123;myname:-garry&#125;\"echo $myname 2、Assign Default Values ${parameter:=word} 12345#!/bin/shecho -en \"What is your name:\"read mynameecho \"Your name is : $&#123;myname:=garry&#125;\"echo $myname 3、Display Error if Null or Unset ${parameter:?word} 12345#!/bin/shecho -en \"What is your name:\"read mynameecho \"Your name is : $&#123;myname:?'myname is undefined'&#125;\"echo $myname 4、Use Alternate Value ${parameter:+word} 1234#!/bin/shecho -en \"What is your name:\"echo \"Your name is : $&#123;myname:+shield&#125;\"echo $myname For Loops 1234for &lt;item&gt; in &lt;list&gt;do &lt;commands&gt;done While Loops 1234567891011121314while [ &lt;condition&gt; ]do &lt;commands&gt;donewhile :do &lt;commands&gt;donewhile read &lt;line&gt;do &lt;commands&gt;done &lt; &lt;file&gt; If / Else If 1234if [ &lt;test&gt; ]then &lt;commands&gt;fi If Else 123456if [ &lt;test&gt; ]then &lt;commands&gt;else &lt;other commands&gt;fi If Elif Else 123456789if [ &lt;test&gt; ]then &lt;commands&gt;elif [ &lt;test&gt; ] then &lt;different commands&gt;else &lt;other commands&gt;fi Case 1234567891011case &lt;variable&gt; in &lt;pattern&gt;) &lt;commands&gt; ;; &lt;other pattern&gt;) &lt;commands&gt; ;; *) &lt;commands&gt; ;;esac Test 1which [ Boolean &amp;&amp; || Hints and Tips 批量创建目录 1mkdir dir_&#123;0,1,2,3,4&#125;.d 只允许输出数字 12345678910read Xecho $X | grep \"[^0-9]\" &gt; /dev/null 2&gt;&amp;1if [ \"$?\" -eq \"0\" ]; then echo \"Bad\"else echo \"Good\" if [ \"$X\" -eq \"10\" ]: then &lt;commands&gt; ifif 输出所有调用变量 123456#!/bin/shwhile [ \"$#\" -gt \"0\" ]do echo \"\\$1 is $1\" shiftdone","link":"/2018/08/06/shell-scripting/"}],"tags":[{"name":"Diary","slug":"Diary","link":"/tags/Diary/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Gif","slug":"Gif","link":"/tags/Gif/"},{"name":"Kap","slug":"Kap","link":"/tags/Kap/"},{"name":"Nvm","slug":"Nvm","link":"/tags/Nvm/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shortcuts","slug":"Shortcuts","link":"/tags/Shortcuts/"},{"name":"Systemd","slug":"Systemd","link":"/tags/Systemd/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"Pyenv","slug":"Pyenv","link":"/tags/Pyenv/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"Memcached","slug":"Memcached","link":"/tags/Memcached/"},{"name":"SELinux","slug":"SELinux","link":"/tags/SELinux/"},{"name":"Grunt","slug":"Grunt","link":"/tags/Grunt/"},{"name":"Rsync","slug":"Rsync","link":"/tags/Rsync/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Emoji","slug":"Emoji","link":"/tags/Emoji/"},{"name":"Jupyter","slug":"Jupyter","link":"/tags/Jupyter/"},{"name":"MariaDB","slug":"MariaDB","link":"/tags/MariaDB/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"}],"categories":[{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"VS Code","slug":"VS-Code","link":"/categories/VS-Code/"},{"name":"MacOS","slug":"MacOS","link":"/categories/MacOS/"},{"name":"Node.Js","slug":"Node-Js","link":"/categories/Node-Js/"},{"name":"Google","slug":"Google","link":"/categories/Google/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"VMware","slug":"VMware","link":"/categories/VMware/"},{"name":"CentOS","slug":"CentOS","link":"/categories/CentOS/"},{"name":"MacOS","slug":"VMware/MacOS","link":"/categories/VMware/MacOS/"},{"name":"Memcached","slug":"CentOS/Memcached","link":"/categories/CentOS/Memcached/"},{"name":"MariaDB","slug":"CentOS/MariaDB","link":"/categories/CentOS/MariaDB/"},{"name":"Shell","slug":"Linux/Shell","link":"/categories/Linux/Shell/"}]}